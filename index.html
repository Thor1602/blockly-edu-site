<!DOCTYPE html>
<!--suppress JSUnusedGlobalSymbols, UnnecessaryLocalVariableJS, CssUnusedSymbol, JSUnusedLocalSymbols, JSUnresolvedReference -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CodeRecess by Mr. Thorben</title>
    <base target="_top">
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css"
          integrity="sha512-Evv84Mr4kqVGRNSgIGL/F/aIDqQb7xQ2vcrdIwxfjThSH8CSR7PBEakCr51Ck+w+/U6swU2Im1vVX0SVk9ABhg=="
          crossorigin="anonymous" referrerpolicy="no-referrer"/>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.5.1/gsap.min.js"></script>
    <script src="https://unpkg.com/blockly/blockly_compressed.js"></script>
    <script src="https://unpkg.com/blockly/blocks_compressed.js"></script>
    <script src="https://unpkg.com/blockly/javascript_compressed.js"></script>
    <script src="https://unpkg.com/blockly/msg/en.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.1.3/pixi.min.js"></script>
    <script src="https://w.soundcloud.com/player/api.js"></script> <!-- Load SoundCloud API -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <style>

        body {
            padding: 0;
        }

        body, html {
            height: 100%;
            margin: 0;
        }

        .btn-primary {
            background-color: #FF9800 !important;
            color: white !important;
            border-color: #FF9800 !important;
        }

        .btn-primary:hover,
        .btn-primary:visited,
        .btn-primary:active,
        .btn-primary:focus {
            background-color: #FF9800 !important;
            color: white !important;
            border-color: #FF9800 !important;
            box-shadow: none !important; /* Remove Bootstrap focus shadow */
        }

        .btn-primary:hover {
            box-shadow: 0 0 10px black !important; /* Adds black glow effect */
        }

        .btn-warning {
            background-color: #f44336 !important; /* Bright red or deep orange */
            color: white !important;
            border-color: #f44336 !important;
        }

        .btn-warning:hover,
        .btn-warning:visited,
        .btn-warning:active,
        .btn-warning:focus {
            background-color: #d32f2f !important;
            color: white !important;
            border-color: #d32f2f !important;
            box-shadow: none !important;
        }

        .btn-warning:hover {
            box-shadow: 0 0 10px red !important;
        }

        .fa-2xl {
            padding: 14px;
        }


        .btn-reset {
            background-color: #7200c3 !important;
            color: white !important;
            border-color: #7200c3 !important;
            display: none;
        }

        .btn-reset:hover,
        .btn-reset:visited,
        .btn-reset:active,
        .btn-reset:focus {
            background-color: #7200c3 !important;
            color: white !important;
            border-color: #7200c3 !important;
            box-shadow: none !important; /* Remove Bootstrap focus shadow */
        }

        .btn-reset:hover {
            box-shadow: 0 0 10px black !important; /* Adds black glow effect */
        }

        .pre-hint-container {
            margin-top: 10px;
            height: 25px;
        }

        .progress-container {
            display: flex; /* Flex layout */
            align-items: center; /* Vertically center the circles */
            justify-content: center; /* Horizontally center the whole group */
            gap: 10px; /* Space between circles */

            padding: 2px 10px;
            height: 30px;
            background-color: white;
            border-radius: 20px;
        }

        .progress-dot {
            width: 15px;
            height: 15px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: white;
        }

        .progress-dot.current-level {
            width: 30px;
            height: 30px;
            font-size: 14px;
        }

        .hint-container {
            margin-left: 20px;
            height: 25px;
            background-color: white;
            color: black;
            padding-left: 20px;
            padding-right: 20px;
            border-radius: 20px;
        }

        .email-container {
            margin-right: 20px;
            margin-left: 20px;
            height: 40px;
            background-color: white;
            color: black;
            padding-left: 20px;
            padding-right: 20px;
            border-radius: 20px;
        }

        .offcanvas {
            position: fixed;
            top: 0;
            right: -280px; /* Initially hidden */
            width: 280px;
            height: 100%;
            text-shadow: 0 2px 3px rgba(0, 0, 0, 0.4); /* subtle contrast */
            background: linear-gradient(135deg, #ffc107, #cc9b00);
            color: white;
            overflow-y: auto;
            transition: right 0.4s ease;
            padding-top: 60px;
            z-index: 1050;
            box-shadow: -4px 0 20px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(5px);
            border-left: 3px solid rgba(255, 255, 255, 0.1);
        }

        .offcanvas.show {
            right: 0;
        }

        .offcanvas a {
            color: white;
            padding: 12px 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            text-decoration: none;
            font-weight: 500;
            font-size: 16px;
            transition: all 0.25s ease;
            position: relative;
        }

        .offcanvas a::before {
            color: #fff;
            font-size: 18px;
            transition: transform 0.3s ease;
        }

        .offcanvas a:hover {
            background-color: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            padding-left: 30px;
        }

        .offcanvas a:hover::before {
            transform: scale(1.4);
            color: #ffe4be;
        }


        .close-btn {
            position: absolute;
            top: 10px;
            right: 20px;
            font-size: 50px;
            cursor: pointer;
            transition: transform 0.2s ease-in-out;

        }

        .close-btn:hover {
            transform: translateY(-5px);
        }

        /* Dark overlay when menu opens */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1045; /* Just below the sidebar */
            display: none; /* Hidden by default */
        }

        .overlay.show {
            display: block; /* Show when menu opens */
        }

        /* Navbar */
        .navbar {
            position: relative; /* No overlapping */
            z-index: 1030; /* Lower than sidebar */
        }

        /* Content */
        .content {
            padding: 20px;
        }

        .active-bg-sidebar {
            background-color: #ffc107; /* yellow theme */
        }

        .bg-sidebar {
            background-color: #ffc107; /* yellow theme */
        }

        /* styling for nav bar END */

        .grade-card {
            background: rgba(255, 255, 255, 0.7);
            border-radius: 20px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            transition: transform 0.2s ease-in-out;
        }

        .grade-card:hover {
            transform: translateY(-5px);
        }

        .grade-title {
            background: linear-gradient(135deg, #ff9800, #fbbb60);
            color: white;
            padding: 0.4rem;
            border-radius: 10px;
            text-align: center;
            font-weight: bold;
            margin-bottom: 1rem;
            font-size: 1.2rem;
        }

        .section-title {
            font-size: 0.9rem;
            font-weight: 600;
            margin-top: 1rem;
            margin-bottom: 0.3rem;
            color: #333;
        }

        .exercise-link {
            text-decoration: none;
            color: #4e54c8;
            font-weight: 500;
            display: inline-block;
            transition: transform 0.2s, color 0.2s;
        }

        .exercise-link:hover {
            color: #2d2d94;
            transform: scale(1.1);
        }

        @media (max-width: 768px) {
            .row-cols-lg-6 > * {
                flex: 0 0 50%;
                max-width: 50%;
            }
        }

        .icon-circle {
            background: white;
            border-radius: 50%;
            padding: 10px;
            color: #ffac31;
            box-shadow: 0 0 0 2px #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            font-size: 18px;
        }

        #visualisationSize {
            border-radius: 0.75rem;
            padding: 0.2rem 0.3rem;
            font-size: 1.1rem;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.6);
            background-color: #f8f9fa;
            transition: box-shadow 0.2s ease-in-out;
        }

        #visualisationSize:focus {

            box-shadow: 0 0 0 0.25rem rgb(255, 211, 145);
        }

        .expand {
            text-shadow: 0 2px 3px rgba(0, 0, 0, 0.4); /* subtle contrast */
            transition: transform 0.25s ease-in-out; /* Slower expand */
        }

        .expand:hover {
            transform: scale(1.1);
        }

        #paneWrapper {
            position: relative;
            width: 100%;
            height: 100vh;
            overflow: hidden;
        }

        .tab-pane {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .blocklyHighlighted > .blocklyPath {
            stroke: rgba(255, 213, 34, 0.67) !important;
            stroke-width: 4px !important;
            fill: rgba(255, 255, 255, 0.18) !important;
        }


        .blockly-overlay {
            /*cursor: url('images/lock-solid.svg') 16 16, not-allowed;*/
            display: none;
            position: absolute;
            inset: 0;
            background: rgba(255, 255, 255, 0.1);
            z-index: 20; /* make sure it's above Blockly */
            pointer-events: all;
        }


    </style>

</head>
<body>

<nav class="navbar navbar-dark bg-warning">
    <div class="container-fluid d-flex justify-content-between align-items-center">

        <!-- Left side -->
        <div class="d-flex align-items-center">
            <a href="#" id="homeLink" class="navbar-brand me-3 expand">
                <img src="https://raw.githubusercontent.com/Thor1602/blockly-edu-site/main/images/logo.png" height="40"
                     width="40" alt=""/>
                CodeRecess SAIS
            </a>
            <button class="btn btn-lg btn-primary" onclick="showPane('codingPane')">Continue</button>
        </div>

        <!-- Right side -->
        <div class="d-flex align-items-center gap-3">
            <a class="nav-link email-container disabled" id="activeUserEmail"></a>

            <label for="visualisationSize"></label>
            <select class="form-select form-select-sm" id="visualisationSize" style="max-width: 200px;">
                <option selected disabled>Game Size</option>
                <option value="Extra Small">Extra Small</option>
                <option value="Small">Small</option>
                <option value="Medium">Medium</option>
                <option value="Large">Large</option>
                <option value="Extra Large">Extra Large</option>
            </select>
            <button class="navbar-toggler expand" type="button" onclick="toggleMenu()">
                <i class="fa-solid fa-user icon-circle"></i></button>
        </div>

    </div>
</nav>


<!-- Dark Overlay (Shades Background) -->
<div id="overlay" class="overlay" onclick="toggleMenu()"></div>

<!-- OffCanvas Sidebar Menu -->
<div id="sidebar" class="offcanvas">
    <span class="close-btn" onclick="toggleMenu()">&times;</span>
    <ul class="nav flex-column link-container" id="sidebarMenu">
        <!-- Grades with Submenus -->
        <li class="nav-item"><h3 class="activeUserName"></h3></li>
        <li class="nav-item">
            <a href="#" class="nav-link dropdown-toggle" data-toggle="collapse" data-target="#kinderMenu"
               data-parent="#sidebarMenu">Kinder</a>
            <div id="kinderMenu" class="collapse">
                <a href="#" class="nav-link pl-4" data-param="taxiDriverSequencingK">Sequencing</a>
            </div>
        </li>
        <li class="nav-item">
            <a href="#" class="nav-link dropdown-toggle" data-toggle="collapse" data-target="#grade1Menu"
               data-parent="#sidebarMenu">Grade 1</a>
            <div id="grade1Menu" class="collapse">
                <a href="#" class="nav-link pl-4" data-param="taxiDriverSequencing1">Sequencing</a>
            </div>
        </li>
        <li class="nav-item">
            <a href="#" class="nav-link dropdown-toggle" data-toggle="collapse" data-target="#grade2Menu"
               data-parent="#sidebarMenu">Grade 2</a>
            <div id="grade2Menu" class="collapse">
                <a href="#" class="nav-link pl-4">Sequencing</a>
                <div class="pl-5">
                    <a href="#" class="nav-link" data-param="taxiDriverSequencing2">Mr. Cab Driver</a>
                </div>
            </div>
        </li>
        <li class="nav-item">
            <a href="#" class="nav-link dropdown-toggle" data-toggle="collapse" data-target="#grade3Menu"
               data-parent="#sidebarMenu">Grade 3</a>
            <div id="grade3Menu" class="collapse">
                <a href="#" class="nav-link pl-4">Sequencing</a>
                <div class="pl-5">
                    <a href="#" class="nav-link" data-param="taxiDriverSequencing3">Mr. Cab Driver</a>
                </div>
            </div>
        </li>
        <li class="nav-item">
            <a href="#" class="nav-link dropdown-toggle" data-toggle="collapse" data-target="#grade4Menu"
               data-parent="#sidebarMenu">Grade 4</a>
            <div id="grade4Menu" class="collapse">
            </div>
        </li>
        <li class="nav-item">
            <a href="#" class="nav-link dropdown-toggle" data-toggle="collapse" data-target="#grade5Menu"
               data-parent="#sidebarMenu">Grade 5</a>
            <div id="grade5Menu" class="collapse">
            </div>
        </li>
    </ul>
</div>
<div id="paneWrapper">

    <div id="loadingPane" class="tab-pane d-flex justify-content-center align-items-center flex-column"
         style="display: none;">
        <div class="text-center">
            <div class="spinner-border text-primary" role="status" style="width: 4rem; height: 4rem;">
                <span class="visually-hidden">Loading...</span>
            </div>
            <h4 class="mt-4" id="loadingText">Loading...</h4>
            <h5 id="successText" class="mt-3 text-success fw-bold" style="display: none;">You're logged in!</h5>
        </div>
    </div>

    <div id="home" class="tab-pane overflow-auto" style="display: none;">
        <div class="container">
            <h1 class="text-center mb-5 fw-bold">âœ¨ Coding Activities âœ¨</h1>
            <h3 class="text-center mb-5 fw-bold activeUserName"></h3>
            <div class="row row-cols-1 row-cols-md-3 row-cols-lg-3 g-4 link-container">
                <div class="col">
                    <div class="grade-card h-100">
                        <div class="grade-title">Grade K</div>
                        <div>
                            <div class="section-title">Sequencing</div>
                            <a href="#" class="exercise-link" data-param="taxiDriverSequencingK">Mr. Cab
                                Driver</a>
                        </div>
                        <div>
                            <div class="section-title">Loops</div>
                            <a>Coming soon</a>
                        </div>
                        <div>
                            <div class="section-title">Debugging</div>
                            <a>Dojo Troubles (Coming soon)</a>
                        </div>
                    </div>
                </div>

                <div class="col">
                    <div class="grade-card h-100">
                        <div class="grade-title">Grade 1</div>
                        <div>
                            <div class="section-title">Sequencing</div>
                            <a href="#" class="exercise-link" data-param='taxiDriverSequencing1'>Mr. Cab
                                Driver</a>
                        </div>
                        <div>
                            <div class="section-title">Loops</div>
                            <a>Coming soon</a>
                        </div>
                        <div>
                            <div class="section-title">Debugging</div>
                            <a>Dojo Troubles (Coming soon)</a>
                        </div>
                        <div>
                            <div class="section-title">Events</div>
                            <a>Dojo Play (Coming soon)</a>


                        </div>
                    </div>
                </div>

                <div class="col">
                    <div class="grade-card h-100">
                        <div class="grade-title">Grade 2</div>
                        <div>
                            <div class="section-title">Sequencing</div>
                            <a href="#" class="exercise-link" data-param='taxiDriverSequencing2'>Mr. Cab
                                Driver</a>
                        </div>
                        <div>
                            <div class="section-title">Loops</div>
                            <a>Contact</a>
                        </div>
                        <div>
                            <div class="section-title">Debugging</div>
                            <a>Coming soon</a>
                        </div>
                        <div>
                            <div class="section-title">Events</div>
                            <a>Ms. Jeniffer's Mayhem (Coming soon)</a>
                        </div>
                    </div>
                </div>

                <div class="col">
                    <div class="grade-card h-100">
                        <div class="grade-title">Grade 3</div>
                        <div>
                            <div class="section-title">Sequencing</div>
                            <a href="#" class="exercise-link" data-param='taxiDriverSequencing3'>Mr. Cab
                                Driver</a>
                        </div>
                        <div>
                            <div class="section-title">Loops</div>
                            <a>Coming soon</a>
                        </div>
                        <div>
                            <div class="section-title">Debugging</div>
                            <a>Coming soon</a>
                        </div>
                        <div>
                            <div class="section-title">Events</div>
                            <a href="#" class="exercise-link" data-param='gymMayhem3'>Ms. Jeniffer's Mayhem</a>
                        </div>
                        <div>
                            <div class="section-title">Conditionals</div>
                            <a href="#" class="exercise-link" data-param='bookSorting4'>Ms. Taery's Agony</a>
                        </div>
                    </div>
                </div>

                <div class="col">
                    <div class="grade-card h-100">
                        <div class="grade-title">Grade 4</div>
                        <div>
                            <div class="section-title">Loops</div>
                            <a>Coming soon</a>
                        </div>
                        <div>
                            <div class="section-title">Debugging</div>
                            <a>Coming soon</a>
                        </div>
                        <div>
                            <div class="section-title">Events</div>
                            <a>Ms. Jeniffer's Mayhem (Coming soon)</a>
                        </div>
                        <div>
                            <div class="section-title">Conditionals</div>
                            <a>Ms. Taery's Agony (Coming soon)</a>
                        </div>
                        <div>
                            <div class="section-title">Nested Loops</div>
                            <a>Coming soon</a>
                        </div>
                        <div>
                            <div class="section-title">Operators</div>
                            <a>Coming soon</a>
                        </div>
                        <div>
                            <div class="section-title">Variables</div>
                            <a>Coming soon</a>
                        </div>
                    </div>
                </div>

                <div class="col">
                    <div class="grade-card h-100">
                        <div class="grade-title">Grade 5</div>
                        <div>
                            <div class="section-title">Loops</div>
                            <a>Coming soon</a>
                        </div>
                        <div>
                            <div class="section-title">Debugging</div>
                            <a>Coming soon</a>
                        </div>
                        <div>
                            <div class="section-title">Events</div>
                            <a>Ms. Jeniffer's Mayhem (Coming soon)</a>
                        </div>
                        <div>
                            <div class="section-title">Conditionals</div>
                            <a>Ms. Taery's Agony (Coming soon)</a>
                        </div>
                        <div>
                            <div class="section-title">Nested Loops</div>
                            <a>Coming soon</a>
                        </div>
                        <div>
                            <div class="section-title">Conditional Loops</div>
                            <a>Coming soon</a>
                        </div>
                        <div>
                            <div class="section-title">Advanced Loops</div>
                            <a>Coming soon</a>
                        </div>
                        <div>
                            <div class="section-title">Functions</div>
                            <a>Ms. Minjaeâ€™s Melody Functions (Coming soon)</a>
                        </div>
                        <div>
                            <div class="section-title">Operators</div>
                            <a>Coming soon</a>
                        </div>
                        <div>
                            <div class="section-title">Variables</div>
                            <a>Coming soon</a>
                        </div>
                    </div>
                </div>

            </div>
        </div>
    </div>
    <div id="codingPane" class="tab-pane overflow-auto" style="display: none;">
        <div class="container-fluid vh-100 d-flex flex-row content">
            <!-- Left Side (Visualization) -->
            <div class="d-flex flex-column overflow-auto">
                <div id="visualisation" class="border rounded bg-light p-2"></div>

                <div class="mt-3 d-flex justify-content-between">
                    <button class="btn btn-lg btn-primary" id="btnRun">
                        <i class="fa-solid fa-play"></i> RUN
                    </button>
                    <button class="btn btn-lg btn-reset" id="btnReset">
                        <i class="fa-solid fa-rotate-right"></i> RESET
                    </button>
                    <button class="btn btn-lg btn-primary" id="btnStep">
                        <i class="fa-solid fa-forward-step"></i> STEP
                    </button>
                </div>
                <label for="speed" class="form-label"></label>
                <input type="range" class="form-range" min="0" max="10" step="1" id="speed" style="display: none">

            </div>

            <div class="d-flex flex-column flex-grow-1 mx-3">
                <div class="bg-warning p-3 ml-5 sticky-top">

                    <!-- EVERYTHING IN ONE HORIZONTAL LINE -->
                    <div class="d-flex align-items-center gap-3 flex-wrap">
                        <!-- Dot Progress Bar -->
                        <div class="d-flex justify-content-center progress-container" style="gap: 10px;"></div>

                        <!-- Button Group -->
                        <div class="d-flex gap-2 flex-wrap">
                            <button class="btn btn-lg btn-primary" tabindex="0" data-bs-toggle="tooltip"
                                    data-bs-placement="top"
                                    title="Turn the sound on/off" id="soundButton">
                                <i class="fa-solid fa-volume-high"></i>
                            </button>

                            <button class="btn btn-lg btn-primary" id="blocksLeftover" data-bs-toggle="tooltip"
                                    data-bs-placement="top" title="See here the blocks you have left.">
                                <span id="numberBlockCapacity"></span> block(s)
                                <span id="contentBlockCapacity"></span>
                            </button>
                            <button class="btn btn-lg btn-primary nextLevelBtn" tabindex="0" data-bs-toggle="tooltip"
                                    data-bs-placement="top"
                                    title="Click here to go to the next level when the level completed" disabled>
                                <i class="fa-solid fa-right-long fa-2xl"></i>Next
                            </button>

                            <button class="btn btn-lg btn-primary" data-toggle="modal" data-target="#omgTeacherModal"
                                    data-bs-toggle="tooltip" data-bs-placement="top"
                                    title="OMG Mr.Thorben!! I found an error and you should fix it!!">
                                <i class="fa-solid fa-bug fa-2xl"></i>
                            </button>

                            <button class="btn btn-lg btn-primary" data-toggle="modal" data-target="#instructionsModal"
                                    data-bs-toggle="tooltip" data-bs-placement="top"
                                    title="Click here for instructions">
                                <i class="fa-solid fa-person-chalkboard fa-2xl"></i>
                            </button>

                            <button class="btn btn-lg btn-primary" data-toggle="modal" data-target="#hintModal"
                                    tabindex="0"
                                    data-bs-toggle="tooltip" data-bs-placement="top"
                                    title="Click here for a hint if enabled" disabled>
                                <i class="fa-solid fa-question fa-2xl"></i>
                            </button>
                        </div>
                    </div>
                    <!-- Live Feedback Container -->
                    <div class="d-flex align-items-center mt-2">
                        <div class="pre-hint-container" id="liveFeedback"></div>
                    </div>
                </div>

                <div class="border rounded bg-white p-2 flex-grow-1 position-relative">
                    <div id="blocklyDiv" style="height: 100%; width: 100%;"></div>
                    <div id="blocklyOverlay" class="blockly-overlay"></div>
                </div>
            </div>
        </div>
    </div>
</div>


<!-- Warning Modal -->
<div class="modal fade" id="warningModal" tabindex="-1" role="dialog" aria-labelledby="warningModalLabel"
     aria-hidden="true">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="warningModalLabel">Warning</h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body">
                This level is in development.
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-primary" data-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>

<div class="modal fade" id="omgTeacherModal" tabindex="-1" role="dialog" aria-labelledby="omgTeacherModalLabel"
     aria-hidden="true">
    <div class="modal-dialog" role="document">
        <div class="modal-content modal-dialog-centered">
            <div class="modal-header">
                <h5 class="modal-title" id="omgTeacherModalLabel">The "I found a bug" report</h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <form>
                <div class="modal-body">
                    <div class="form-group">
                        <label for="bugContent">Describe the bug and where it happened</label>
                        <textarea class="form-control" id="bugContent" name="bugDescription" rows="3"></textarea>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-primary" data-dismiss="modal">Close</button>
                    <button type="button" class="btn btn-primary" id="sendBtnBugForm">Send to Mr. Thorben</button>
                </div>
            </form>

        </div>
    </div>
</div>

<div class="modal fade" id="instructionsModal" tabindex="-1" role="dialog" aria-labelledby="instructionsModalLabel"
     aria-hidden="true">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="instructionsModalLabel">Instructions</h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body" id="instructionsContent">
                No instructions
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-primary" data-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>

<div class="modal fade" id="hintModal" tabindex="-1" role="dialog" aria-labelledby="hintModalLabel"
     aria-hidden="true">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="hintModalLabel">Hint</h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body" id="hintContent">
                No hints
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-primary" data-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>

<div class="modal fade" id="nextLevelModal" tabindex="-1" role="dialog" aria-labelledby="nextLevelModalLabel"
     aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-centered" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title" id="nextLevelModalLabel">CONGRATULATIONS</h3>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body" id="feedback">

            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" id="retryBeforeNextLevel" data-dismiss="modal">Retry
                </button>
                <button type="button" class="btn btn-lg btn-primary nextLevelBtn" disabled><i
                        class="fa-solid fa-right-long fa-2xl"></i>Next
                </button>
            </div>
        </div>
    </div>
</div>
<script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.bundle.min.js"></script>

<script>
    buttonSpeedElement = document.getElementById('speed');
    buttonRunElement = document.getElementById("btnRun");
    buttonResetElement = document.getElementById("btnReset");
    buttonStepElement = document.getElementById("btnStep");
    numberBlockCapacityElement = document.getElementById("numberBlockCapacity");
    contentBlockCapacityElement = document.getElementById("contentBlockCapacity");
    buttonCapacityElement = document.getElementById("blocksLeftover");
    soundButtonElement = document.getElementById("soundButton");
    buttonVisualisationElement = document.getElementById("visualisation");
    buttonLiveFeedbackElement = document.getElementById("liveFeedback");
    buttonHintModalElement = document.getElementById("hintModal");
    buttonInstructionsModalElement = document.getElementById("instructionsModal");
    buttonSendBugFormElement = document.getElementById("sendBtnBugForm");
    retryBeforeNextLevelElement = document.getElementById("retryBeforeNextLevel");
    feedbackElement = document.getElementById("feedback");
    hintContentElement = document.getElementById("hintContent");
    instructionsContentElement = document.getElementById("instructionsContent");
    blocklyDivElement = document.getElementById('blocklyDiv');
    visualisationSize = document.getElementById("visualisationSize");

    buttonNextLevelElements = document.querySelectorAll(".nextLevelBtn");

    $nextLevelModal = $("#nextLevelModal");
    $omgTeacherModal = $("#omgTeacherModal");
    window.onload = function () {
        disableLinks();
        buttonNextLevelElements.forEach(button => {
            button.disabled = true;
        });
        if (sessionStorage.getItem("loggedIn") && sessionStorage.getItem("loggedIn") === "true") {
            loadUser();
        } else {
            initUserDataAndSession();
        }

    }


    function initUserDataAndSession() {
        console.log("initUserDataAndSession() called"); // Step 1
        try {
            // noinspection JSUnresolvedVariable
            google.script.run
                .withSuccessHandler(function (studentData) {
                    const email = studentData[0][0];
                    const firstname = studentData[0][1];
                    const lastname = studentData[0][2];
                    const studentId = studentData[0][3];
                    const className = studentData[0][4];
                    const grade = studentData[0][5];
                    console.log(studentData[1]);
                    sessionStorage.setItem("studentProgress", JSON.stringify(studentData[1]));
                    sessionStorage.setItem("loggedIn", "true");
                    sessionStorage.setItem("currentLessonType", studentData[2]);
                    sessionStorage.setItem("currentLessonLevel", studentData[3]);
                    sessionStorage.setItem("email", email);
                    sessionStorage.setItem("firstname", firstname);
                    sessionStorage.setItem("lastname", lastname);
                    sessionStorage.setItem("studentId", studentId);
                    sessionStorage.setItem("className", className);
                    sessionStorage.setItem("grade", grade);
                    showPane('codingPane');
                    renderProgressBar(sessionStorage.getItem("currentLessonType"));
                    init(sessionStorage.getItem("currentLessonType"), sessionStorage.getItem("currentLessonLevel"));
                    document.getElementById("activeUserEmail").innerText = email;
                    document.querySelectorAll(".activeUserName").forEach(el => {
                        el.innerText = "ðŸ’› Hi " + firstname + " " + lastname + " (" + className + ") ðŸ’›";
                    });
                    setTimeout(() => {
                        handleLoginStatus(true);
                    }, 200);
                    enableLinks();

                })
                .withFailureHandler(function (error) {
                    console.error("Failed to get user email:", error.message || error);
                    document.getElementById("activeUserEmail").innerText = "Please login with your Google account!";
                    setTimeout(() => {
                        handleLoginStatus(false);
                    }, 200);
                })
                .getStudentData();
        } catch (e) {
            document.getElementById("activeUserEmail").innerText = "Login failed, Mr. Thorben must fix this.";
            setTimeout(() => {
                handleLoginStatus(false);
            }, 200);
            enableLinks();
        }
    }

    function loadUser() {
        console.log("loadUser() called"); // Step 1
        document.getElementById("activeUserEmail").innerText = sessionStorage.getItem("email");
        document.querySelectorAll(".activeUserName").forEach(el => {
            el.innerText = "ðŸ’› Hi " + sessionStorage.getItem("firstname") + " " + sessionStorage.getItem("lastname") + " (" + sessionStorage.getItem("className") + ") ðŸ’›";
        });
        enableLinks();
        renderProgressBar(sessionStorage.getItem("currentLessonType"));
        init(sessionStorage.getItem("currentLessonType"), sessionStorage.getItem("currentLessonLevel"));
        if (sessionStorage.getItem("setNextLevel") === "true") {
            showPane('codingPane');
            sessionStorage.setItem("setNextLevel", "false");
        } else if (sessionStorage.getItem("setNextLesson") === "true") {
            showPane('codingPane');
            sessionStorage.setItem("setNextLesson", "false");
        } else {
            showPane('home');
        }
    }

    let configData = null; // Global variable to store JSON
    async function fetchData() {
        const response = await fetch('https://raw.githubusercontent.com/Thor1602/blockly-edu-site/main/blocks.json' + '?t=' + new Date().getTime());
        configData = await response.json();
    }


    class Activity {
        static gameSettings = null;

        constructor(type, level) {
            this.type = type;
            this.level = level;
            this.gameData = null;
            this.nonInteractiveObjectsOne = []; 
            this.nonInteractiveObjectsTwo = []; 
            this.people = [];  
            this.player = null;
            this.blockManager = null;
            this.startedOn = new Date().toISOString();
            this.map = null; // Initialize as null and set it later asynchronously
            this.app = null; // Initialize as null
            this._gridSize = null;
            this.speed = 1;
            this.speedElement = buttonSpeedElement;
            this.isRunning = false;
            this.isComplete = false;
            this.executionIndex = 0;
            this.executionSequence = null;
            this.overlayContainer = null;

            buttonRunElement.addEventListener("click", () => {
                this.runCode();
            });
            buttonStepElement.addEventListener("click", () => {
                this.stepCode();
            });
            buttonResetElement.addEventListener("click", () => {
                this.resetCode();
            });
            retryBeforeNextLevelElement.addEventListener("click", () => {
                this.resetCode();
            });

            buttonSendBugFormElement.addEventListener("click", () => {
                try {
                    // noinspection JSUnresolvedVariable
                    google.script.run
                        .withSuccessHandler(() => {
                            console.log("Report submitted successfully.");
                            $('#omgTeacherModal').modal('hide');
                            this.giveHint("ðŸ’™ðŸ’›Thank you!!ðŸ’›ðŸ’™", "8000");
                        })
                        .withFailureHandler((error) => {
                            console.error("Error submitting report:", error);
                            $('#omgTeacherModal').modal('hide');
                            this.giveHint("An error happened. Say it to me in person please.", "8000");
                        })
                        .sendSupportEmail("Debug Report from a Student", sessionStorage.getItem("email"), document.getElementById("bugContent").value);
                } catch (e) {
                    console.error("Unexpected error in script.run:", e);
                }
            });

            this.initActivity();
        }

        async initActivity() {
            await this.getExercise();
            await this.initializeActivity();
            await this.initializeBlocklyWorkspace();
            this.addKeyInput(this.runCode, this.resetCode);
            this.visualisationDivSizeListener();
        }

        async getExercise() {
            if (!configData) {
                await fetchData();
            }
            this.gameData = configData.exercises.find(
                exercise => exercise.type === this.type && exercise.level === String(this.level)
            );
            if (localStorage.getItem('visualisationSize') !== null) {
                this._gridSize = localStorage.getItem('visualisationSize');
            } else {
                this._gridSize = this.gameData.gridSize;
            }
            Activity.activityTypeGameSettings = configData.gameSettings.find(gameSetting => gameSetting.category === this.gameData.category);
            Activity.gradeSettings = configData.settingsPerGrade[this.gameData.grade] || {};
            console.log(Activity.gradeSettings);
            feedbackElement.innerHTML = this.gameData.instructions;
            instructionsContentElement.innerHTML = this.gameData.instructions;
            hintContentElement.innerHTML = this.gameData.hints;
            Activity.playSound(Activity.activityTypeGameSettings.sounds.backgroundMusic, true);
        }

        async levelCompleted() {
            Activity.playSound(Activity.activityTypeGameSettings.sounds.levelCompleted);
            await this.addOverlay("Challenge\nCompleted!", 0x000000);
            this.isComplete = true;


            $nextLevelModal.modal({
                backdrop: 'static',
                keyboard: false,
                show: true
            });
        }

        hasFailed() {
            Activity.playSound(Activity.activityTypeGameSettings.sounds.levelFailed);
            this.addOverlay("ðŸ¤”", 0x000000);
            this.isComplete = false;
            console.log("Level Failed");
        }

        async initializeActivity() {
            if (this.speed) {
                this.speedElement.style.display = "inline-block";
                this.speed = this.speedElement.value;
                this.speedElement.oninput = () => this.speed = this.speedElement.value;
            }

            this.app = new PIXI.Application({
                width: this.gameData.rowLength * this._gridSize, // Default placeholder values
                height: this.gameData.colLength * this._gridSize, // Default placeholder values
                backgroundColor: 0xAAAAAA
            });
            this.map = await new MapLayout(this.gameData.grid, this.app);
            if (this.gameData.background.type === "colorTiled"){
                await this.map.initialize(this.gameData.background.mapLayout);
            }

            this.player = new Player(Activity.activityTypeGameSettings.characters.player.sprite, this.gameData.playerInfo.row, this.gameData.playerInfo.col, this.gameData.playerInfo.direction, this.gameData.playerInfo.setNotification, this.gameData.playerInfo.notification, this._gridSize, this.app, this);
            if (Array.isArray(this.gameData.nonInteractiveObjectOnePositions)) {
                for (let pos of this.gameData.nonInteractiveObjectOnePositions) {
                    this.nonInteractiveObjectsOne.push(new Sprite(
                        Activity.activityTypeGameSettings.environment.nonInteractiveObjects.nonInteractiveObjectOne.sprite,
                        pos[0], pos[1],
                        Activity.activityTypeGameSettings.environment.nonInteractiveObjects.nonInteractiveObjectOne.direction,
                        Activity.activityTypeGameSettings.environment.nonInteractiveObjects.nonInteractiveObjectOne.notifications,
                        pos[2],
                        this._gridSize,
                        this.app,
                        this
                    ));
                }
            }
            if (Array.isArray(this.gameData.nonInteractiveObjectTwoPositions)) {
                for (let pos of this.gameData.nonInteractiveObjectTwoPositions) {
                    this.nonInteractiveObjectsTwo.push(new Sprite(
                        Activity.activityTypeGameSettings.environment.nonInteractiveObjects.nonInteractiveObjectTwo.sprite,
                        pos[0], pos[1],
                        Activity.activityTypeGameSettings.environment.nonInteractiveObjects.nonInteractiveObjectTwo.direction,
                        Activity.activityTypeGameSettings.environment.nonInteractiveObjects.nonInteractiveObjectTwo.notifications,
                        pos[2],
                        this._gridSize,
                        this.app,
                        this
                    ));
                }
            }
            this.people = Sprite.listOfSprites.filter(item => !(item instanceof Player));
            // this.nonInteractiveObjectsOne = Sprite.listOfSprites; // might be usesless
            // Append PIXI app view (canvas) to DOM
            buttonVisualisationElement.appendChild(this.app.view);

            this.initializeEnvironment();
            this.map.drawSprites(this.nonInteractiveObjectsOne);  // Pass the correct 'sprites' array
            this.map.drawSprites(this.nonInteractiveObjectsTwo);  // Pass the correct 'sprites' array
        }

        initializeEnvironment() {
            if (!this.map) {
                console.error("Map is not initialized yet.");
                return;
            }
            if (this.gameData.background.type === "colorTiled"){
                this.map.drawMap(Activity.activityTypeGameSettings.mapLayoutDesign.styleMap, this._gridSize);
            }
            else if (this.gameData.background.type === "image"){
                this.map.drawImageBackground(this.gameData.background.image, 16* this._gridSize);
            }
            // Now resize any existing sprites, with defensive checks
            if (this.nonInteractiveObjectsOne && Array.isArray(this.nonInteractiveObjectsOne)) {
                this.nonInteractiveObjectsOne.forEach((sprite) => {
                    try {
                        if (sprite && typeof sprite.resize === 'function') {
                            sprite.resize(this._gridSize);
                        }
                    } catch (error) {
                        console.error("Error resizing sprite:", sprite, error);
                    }
                });
            }
            if (this.nonInteractiveObjectsTwo && Array.isArray(this.nonInteractiveObjectsTwo)) {
                this.nonInteractiveObjectsTwo.forEach((sprite) => {
                    try {
                        if (sprite && typeof sprite.resize === 'function') {
                            sprite.resize(this._gridSize);
                        }
                    } catch (error) {
                        console.error("Error resizing sprite:", sprite, error);
                    }
                });
            }
        }

        visualisationDivSizeListener() {
            visualisationSize.addEventListener("change", () => {
                if (visualisationSize.value === "Medium") {
                    this.resizeActivity(30);
                    localStorage.setItem('visualisationSize', "30");
                } else if (visualisationSize.value === "Large") {
                    this.resizeActivity(40);
                    localStorage.setItem('visualisationSize', "40");
                } else if (visualisationSize.value === "Small") {
                    this.resizeActivity(25);
                    localStorage.setItem('visualisationSize', "25");
                } else if (visualisationSize.value === "Extra Small") {
                    this.resizeActivity(20);
                    localStorage.setItem('visualisationSize', "20");
                } else if (visualisationSize.value === "Extra Large") {
                    this.resizeActivity(45);
                    localStorage.setItem('visualisationSize', "45");
                } else {
                    this.resizeActivity(30);
                    localStorage.setItem('visualisationSize', "30");
                }
            });
        }

        resizeActivity(newGridSize) {
            this._gridSize = newGridSize;

            // Resize all sprites (including player)
            if (this.nonInteractiveObjectsOne) {
                this.nonInteractiveObjectsOne.forEach(sprite => {
                    if (sprite) sprite.resize(newGridSize);
                });
            }
            if (this.nonInteractiveObjectsTwo) {
                this.nonInteractiveObjectsTwo.forEach(sprite => {
                    if (sprite) sprite.resize(newGridSize);
                });
            }
            // Resize player separately if needed
            if (this.player) {
                this.player.resize(newGridSize);
            }

            // Resize map (if you make a resize method in MapLayout)
            if (this.map) {
                if (this.gameData.background.type === "colorTiled"){
                    this.map.drawMap(Activity.activityTypeGameSettings.mapLayoutDesign.styleMap, this._gridSize);
                }
                else if (this.gameData.background.type === "image"){
                    this.map.drawImageBackground(this.gameData.background.image, 16* this._gridSize);
                }
                this.map.drawSprites(this.nonInteractiveObjectsOne);
                this.map.drawSprites(this.nonInteractiveObjectsTwo);
            }

            // Resize PIXI app view/canvas
            if (this.app) {
                this.app.renderer.resize(12 * newGridSize, 16 * newGridSize);
            }
        }


        addOverlay(message, color) {
            if (!this.app || this.overlayContainer) return;
            this.isRunning = false;
            // Create container for overlay elements
            this.overlayContainer = new PIXI.Container();
            // 1. Semi-transparent black rectangle
            const overlay = new PIXI.Graphics();
            overlay.beginFill(color, 0.3); // 30% black
            overlay.drawRect(0, 0, this.app.screen.width, this.app.screen.height);
            overlay.endFill();
            this.overlayContainer.addChild(overlay);
            // 2. Centered "Try Again" text
            const textMessage = new PIXI.Text(message, {
                fontFamily: "Arial",
                fontSize: 48,
                fill: 0xffffff,
                align: "center"
            });
            textMessage.anchor.set(0.5);
            textMessage.x = this.app.screen.width / 2;
            textMessage.y = this.app.screen.height / 2;
            this.overlayContainer.addChild(textMessage);

            // Optional: Make overlay block interactions below
            this.overlayContainer.interactive = true;
            this.overlayContainer.interactiveChildren = false;

            // Add overlay to stage
            this.app.stage.addChild(this.overlayContainer);
        }

        removeOverlay() {
            if (this.overlayContainer) {
                this.app.stage.removeChild(this.overlayContainer);
                this.overlayContainer.destroy({children: true});
                this.overlayContainer = null;
            }
        }


        // what my sprites will do according to the blocks
        pick_up_person() {
            return new Promise(resolve => this.player.getPerson(this, resolve));
        }

        get_book(bookType) {
            return new Promise(resolve => this.player.getBook(this, resolve));
        }

        move_north() {
            return new Promise(resolve => this.player.moveBy(0, -1, this.getMapLayout(), this.speed, this.isRunning, resolve));
        }

        move_south() {
            return new Promise(resolve => this.player.moveBy(0, 1, this.getMapLayout(), this.speed, this.isRunning, resolve));
        }

        move_west() {
            return new Promise(resolve => this.player.moveBy(-1, 0, this.getMapLayout(), this.speed, this.isRunning, resolve));
        }

        move_east() {
            return new Promise(resolve => this.player.moveBy(1, 0, this.getMapLayout(), this.speed, this.isRunning, resolve));
        }

        move_choice_action(direction) {
            const dir = this.player.direction; // e.g., "west", "east", etc.
            let row = 0;
            let col = 0;

            const forwardMap = {
                west: [-1, 0],
                east: [1, 0],
                north: [0, -1],
                south: [0, 1]
            };

            if (direction === "forward") {
                [col, row] = forwardMap[dir];
            } else if (direction === "backward") {
                [col, row] = forwardMap[dir].map(n => -n); // invert direction
            } else {
                console.warn("Invalid move direction:", direction);
                return Promise.resolve(); // nothing happens
            }

            return new Promise(resolve =>
                this.player.moveBy(col, row, this.getMapLayout(), this.speed, this.isRunning, resolve)
            );
        }


        move_all_directions_choice_action(direction) {
            const dir = this.player.direction; // e.g., "west", "east", etc.
            let row = 0;
            let col = 0;

            // Directional vectors for forward movement
            const forwardMap = {
                west: [-1, 0],
                east: [1, 0],
                north: [0, -1],
                south: [0, 1]
            };

            // Directional vectors for left and right relative turns
            const leftMap = {
                north: [-1, 0],
                south: [1, 0],
                east: [0, -1],
                west: [0, 1]
            };

            const rightMap = {
                north: [1, 0],
                south: [-1, 0],
                east: [0, 1],
                west: [0, -1]
            };

            if (direction === "forward") {
                [col, row] = forwardMap[dir];
            } else if (direction === "backward") {
                [col, row] = forwardMap[dir].map(n => -n); // invert forward
            } else if (direction === "left") {
                [col, row] = leftMap[dir];
            } else if (direction === "right") {
                [col, row] = rightMap[dir];
            } else {
                console.warn("Invalid move direction:", direction);
                return Promise.resolve(); // nothing happens
            }

            return new Promise(resolve =>
                this.player.moveBy(col, row, this.getMapLayout(), this.speed, this.isRunning, resolve)
            );
        }


        turnTo(direction) {
            return new Promise(resolve => this.player.turnTo(direction, this.speed, this.isRunning, resolve));
        }

        runCodeBlock() {
            return new Promise(resolve => {
                this.giveHint("The code has started RUNNING", "3000");
                resolve(); // Resolve immediately after showing the hint
            });
        }

        highlightBlock(id) {
            const block = Blockly.getMainWorkspace().getBlockById(id);
            if (block) {
                block.setHighlighted(true);
                setTimeout(() => block.setHighlighted(false), 500);
            }
        }

        // Running Blockly Code
        async runCode() {
            if (this.isRunning) return; // Prevent multiple executions
            this.isRunning = true;
            buttonRunElement.style.display = "none";
            buttonResetElement.style.display = "inline-block";
            let runEventBlock = this.blockManager.workspace.getAllBlocks().find(block => block.type === 'run_event');
            if (!runEventBlock) {
                this.giveHint("Error: Run block is missing. Please add the Run block.", "15000");
                this.hasFailed();
                this.isRunning = false; // Allow execution again
                return;
            }
            this.lockWorkspace();
            javascript.javascriptGenerator.init(this.blockManager.workspace);
            let code = javascript.javascriptGenerator.blockToCode(runEventBlock);

            try {
                await eval(`(async () => {
                    let checkRunning = () => this.isRunning; // Closure to check the flag
                    ${code.split("await").join("if (!checkRunning()) return; await")} // Insert check before each await
                })();`);
            } catch (error) {
                console.error("Error executing code:", error);
            } finally {
                this.isRunning = false;
            }
            buttonNextLevelElements.forEach(button => {
                button.innerHTML = `
              <span class="spinner-grow spinner-grow-sm" role="status" aria-hidden="true"></span> SAVING`;
            });
            const currentLevelIsCompleted = this.isComplete; // this.isComplete doesnt work in withSuccessHandler
            try {
                const xmlDom = Blockly.Xml.workspaceToDom(this.blockManager.workspace);
                const xmlText = Blockly.Xml.domToText(xmlDom);
                const blockExcess = numberBlockCapacityElement.innerText === "over";
                const blocksOver = blockExcess ? parseInt(numberBlockCapacityElement.innerText) : 0;
                // check the insertProgress function. It often comes with a 404 error. Resolve by
                // noinspection JSUnresolvedVariable
                google.script.run
                    .withSuccessHandler(function (submission) {
                        console.log("Progress submitted successfully.");
                        if (currentLevelIsCompleted) {
                            sessionStorage.setItem("studentProgress", JSON.stringify(submission.allStudentProgress));
                            // sessionStorage.setItem("currentLessonType", submission.nextType); // undefined
                            // sessionStorage.setItem("currentLessonLevel", submission.nextLevel);// undefined
                            renderProgressBar(sessionStorage.getItem("currentLessonType"));
                            buttonNextLevelElements.forEach(button => {
                                button.disabled = false;
                                button.innerHTML = `<i class="fa-solid fa-right-long fa-2xl"></i>Next`
                            });
                        } else {
                            buttonNextLevelElements.forEach(button => {
                                button.disabled = true;
                                button.innerHTML = `<i class="fa-solid fa-right-long fa-2xl"></i>Next`
                            });
                        }
                    })
                    .withFailureHandler(function (error) {
                        console.error("Error submitting progress:", error);
                        buttonNextLevelElements.forEach(button => {
                            button.disabled = true;
                            button.innerHTML = `<i class="fa-solid fa-right-long fa-2xl"></i>Next`
                        });

                    })
                    .insertProgress({
                        email: sessionStorage.getItem("email"),
                        className: sessionStorage.getItem("className"),
                        grade: sessionStorage.getItem("grade"),
                        studentId: sessionStorage.getItem("studentId"),
                        type: this.type,
                        level: this.level,
                        workspaceXml: xmlText,
                        feedback: "Solid work!",
                        startedOn: this.startedOn,
                        blockExcess: blockExcess,
                        blocksOver: blocksOver,
                        isCompleted: this.isComplete
                    });

            } catch (e) {
                console.error("Unexpected error in script.run:", e);
            }

        }

        async stepCode() {
            if (!this.executionSequence) {
                const runEventBlock = this.blockManager.workspace.getAllBlocks()
                    .find(block => block.type === 'run_event');
                if (!runEventBlock) {
                    this.giveHint("Error: Run block is missing. Please add the Run block.");
                    return;
                }
                javascript.javascriptGenerator.init(this.blockManager.workspace);
                this.executionSequence = this.getExecutionSequence(runEventBlock);
                this.executionIndex = 0;
            }

            if (this.executionIndex >= this.executionSequence.length) {
                this.giveHint("Step complete! No more blocks to run.");
                return;
            }
            const block = this.executionSequence[this.executionIndex];

            // Optionally highlight the current block
            this.blockManager.workspace.highlightBlock(block.id);

            const code = javascript.javascriptGenerator.blockToCode(block);

            try {
                await eval(`(async () => {
                    ${code}
                })();`);
            } catch (error) {
                console.error("Error in step execution:", error);
            }

            this.executionIndex++;
        }

        resetStepState() {
            this.executionSequence = null;
            this.executionIndex = 0;
        }

        resetCode() {
            this.isRunning = false;
            this.removeOverlay();
            this.resetStepState();
            this.unlockWorkspace();
            buttonResetElement.disabled = true;
            buttonStepElement.disabled = true;
            buttonRunElement.disabled = true;
            buttonResetElement.innerHTML = `
                    <span class="spinner-grow spinner-grow-sm" role="status" aria-hidden="true"></span>
                    LOAD
                `;
            buttonStepElement.innerHTML = `
                    <span class="spinner-grow spinner-grow-sm" role="status" aria-hidden="true"></span>
                    LOAD
                `;
            setTimeout(() => {
                // Draw the sprites (including the new player)
                this.map.drawSprites(this.nonInteractiveObjectsOne);
                this.map.drawSprites(this.nonInteractiveObjectsTwo);
                Sprite.restoreNotificationNumberForAllSprites();
                // Initialize the new player (taxi)
                this.player.initialize();
                // Reset other elements (e.g., people notifications)
                this.people.forEach(sprite => sprite.notify(sprite.original_notif_number));
                this.people.forEach(sprite => sprite.show());
            }, 800); //  delay
            setTimeout(() => {
                buttonResetElement.innerHTML = `<i class="fa-solid fa-rotate-right"></i> RESET`;
                buttonStepElement.innerHTML = `<i class="fa-solid fa-forward-step"></i> STEP`;
                buttonResetElement.disabled = false;
                buttonStepElement.disabled = false;
                buttonRunElement.disabled = false;
                buttonRunElement.style.display = "inline-block"; // Show RUN button
                buttonResetElement.style.display = "none"; // Hide RESET button
            }, 900); //  delay
        }

        getExecutionSequence(startBlock) {
            const sequence = [];
            let current = startBlock;
            while (current) {
                sequence.push(current);
                current = current.getNextBlock();
            }
            return sequence;
        }

        lockWorkspace() {
            document.getElementById('blocklyOverlay').style.display = 'block';
        }

        unlockWorkspace() {
            document.getElementById('blocklyOverlay').style.display = 'none';
        }

        getMapLayout() {
            return this.map.mapLayout;
        }

        async initializeBlocklyWorkspace() {
            if (!configData) {
                await fetchData();
            }
            this.blockManager = new BlockManager(blocklyDivElement, this.gameData.maxBlocks);
            this.blockManager.loadBlocks(this.gameData.blocks, Activity.gradeSettings.font);
        }


        giveHint(message, time) {
            const hint = buttonLiveFeedbackElement;
            $('#liveFeedback').addClass('hint-container');
            hint.textContent = message;
            setTimeout(() => {
                hint.textContent = "";
                $('#liveFeedback').removeClass('hint-container');
            }, time);

        }


        addKeyInput(runCode, resetCode) {
            document.addEventListener("keydown", function (event) {
                const codingPane = document.getElementById("codingPane");

                // 1. Check if codingPane is visible
                if (!codingPane || codingPane.style.display === "none") return;

                // 2. Ignore key events when focus is inside an input, textarea or contenteditable
                const active = document.activeElement;
                const isFormInput = (
                    active.tagName === 'INPUT' ||
                    active.tagName === 'TEXTAREA' ||
                    active.isContentEditable
                );
                if (isFormInput) return;

                // 3. Continue only if above checks passed
                const displayStyle = window.getComputedStyle(buttonRunElement).display;
                const speedSlider = buttonSpeedElement;

                switch (event.code) {
                    case "KeyR":
                        if (displayStyle === "block") {
                            runCode();
                        } else if (displayStyle === "none") {
                            resetCode();
                        }
                        break;

                    case "KeyF":
                        if (speedSlider) {
                            speedSlider.value = Math.min(parseInt(speedSlider.value) + 1, speedSlider.max);
                        }
                        break;

                    case "KeyS":
                        if (speedSlider) {
                            speedSlider.value = Math.max(parseInt(speedSlider.value) - 1, speedSlider.min);
                        }
                        break;
                }
            });
        }

        static playSound(link, isBackground = false) {
            try {
                if (!link) {
                    console.warn("No audio link provided. Skipping playback.");
                    return;
                }
                const audio = new Audio("https://raw.githubusercontent.com/Thor1602/blockly-edu-site/main/audio/" + link);
                if (isBackground) {
                    audio.loop = true;
                    audio.volume = 0.4;
                    window.backgroundMusic = audio;
                }

                audio.play().catch(err => {
                    console.warn("Playback failed:", err);
                });

            } catch (err) {
                console.warn("Error in playSound:", err);
            }
        }


    }


    class MapLayout {
        constructor(grid, app) {
            this.grid = grid; // grid is to add borders so students can easily count the jumps: true/false
            this.app = app;
            this.mapLayout = null;
            this.mapContainer = new PIXI.Container();
            this.app.stage.addChild(this.mapContainer);
        }

        async initialize(mapLayoutName) {
            this.mapLayout = await this.loadMapLayout(mapLayoutName);
        }


        async loadMapLayout(mapLayoutNameParam) {
            try {
                await fetchData();
                // noinspection JSUnresolvedVariable
                const layoutObj = configData.map_layouts.find(layout => layout.name === mapLayoutNameParam);
                return layoutObj ? layoutObj.layout : null;
            } catch (error) {
                console.error("Error fetching JSON:", error);
                return null;
            }
        }

        drawImageBackground(imagePath, desiredHeight) {
            this.reset();

            const texture = PIXI.Texture.from(imagePath);
            const bgSprite = new PIXI.Sprite(texture);

            // Wait until texture is loaded
            if (!texture.baseTexture.valid) {
                texture.baseTexture.once('loaded', () => {
                    this.scaleToHeight(bgSprite, desiredHeight);
                    this.mapContainer.addChild(bgSprite);
                });
            } else {
                this.scaleToHeight(bgSprite, desiredHeight);
                this.mapContainer.addChild(bgSprite);
            }
        }

        scaleToHeight(sprite, height) {
            const originalHeight = sprite.texture.height;
            const scaleFactor = height / originalHeight;

            sprite.scale.set(scaleFactor); // Maintains aspect ratio
            sprite.x = 0;
            sprite.y = 0;
        }


        drawMap(styleMap, gridSize) {
            this.reset();
            let rowIndex = 0;

            const textureKeys = {
                3: 'secondaryTile',
                4: 'tertiaryTile',
                5: 'quaternaryTile',
                6: 'quinaryTile',
                7: 'senaryTile'
            };

            for (const rowKey in this.mapLayout) {
                let colIndex = 0;

                for (const colKey in this.mapLayout[rowKey]) {
                    const tileValue = this.mapLayout[rowKey][colKey];
                    const x = colIndex * gridSize;
                    const y = rowIndex * gridSize;

                    let tile;

                    if (tileValue === 3 || tileValue === 4 || tileValue === 5 || tileValue === 6 || tileValue === 7) {
                        const textureKey = textureKeys[tileValue];
                        const imageName = this.textureMap?.[textureKey];

                        if (imageName) {
                            const texture = PIXI.Texture.from(imageName);
                            tile = new PIXI.Sprite(texture);
                            tile.x = x;
                            tile.y = y;
                            tile.width = gridSize;
                            tile.height = gridSize;
                        } else {
                            // Fallback to color fill
                            const colorKey = {
                                3: 'secondaryColor',
                                4: 'tertiaryColor',
                                5: 'quaternaryColor',
                                6: 'quinaryColor',
                                7: 'senaryColor'
                            }[tileValue];

                            const fillColor = Number(styleMap[colorKey]);
                            tile = new PIXI.Graphics();
                            if (this.grid) tile.lineStyle(1, 0x9b9b9b, 1);
                            tile.beginFill(fillColor);
                            tile.drawRect(x, y, gridSize, gridSize);
                            tile.endFill();
                        }
                    } else {
                        // Regular color-based tiles
                        let fillColor;
                        if (tileValue === 1) {
                            fillColor = Number(styleMap.sideColor);
                        } else if (tileValue === 2) {
                            const rand = Math.floor(Math.random() * styleMap.decorationColors.length);
                            fillColor = Number(styleMap.decorationColors[rand]);
                        } else {
                            fillColor = Number(styleMap.walkableColor);
                        }

                        tile = new PIXI.Graphics();
                        if (this.grid) tile.lineStyle(1, 0x9b9b9b, 1);
                        tile.beginFill(fillColor);
                        tile.drawRect(x, y, gridSize, gridSize);
                        tile.endFill();
                    }
                    this.mapContainer.addChild(tile);
                    colIndex++;
                }
                rowIndex++;
            }
        }


        drawSprites(listOfSprites) {
            if (listOfSprites) {
                listOfSprites.forEach((sprite) => {
                    if (sprite) this.app.stage.addChild(sprite.container);
                });
            }
        }

        reset() {
            if (this.mapContainer) {
                this.mapContainer.removeChildren();
            }
        }
    }

    class BlockManager {
        constructor(blocklyDiv, maxBlocks) {
            this.blocklyDiv = blocklyDiv;
            this.maxBlocks = maxBlocks;
            this.workspace = null;
            this.customTheme = null;
        }

        loadBlocks(blocks, fontStyle) {
            try {
                const filteredBlocks = blocks
                    .map(type => configData.blocks.find(block => block.type === type))
                    .filter(Boolean);
                // noinspection JSUnresolvedVariable
                console.log(configData.blocklyThemeSettings["customTheme"]);
                this.loadTheme(configData.blocklyThemeSettings["customTheme"], fontStyle);
                this.defineBlocks(filteredBlocks);
                this.createToolbox(filteredBlocks);
                this.injectWorkspace();
                this.setupChangeListener();
                this.setupResizeObserver(); // Add resize listener

            } catch (error) {
                console.error('Error loading Blockly settings:', error);
            }
        }

        loadTheme(themeSettings, fontStyle) {
            if (themeSettings) {
                this.customTheme = Blockly.Theme.defineTheme(themeSettings.themeName, {
                    base: Blockly.Themes[themeSettings.base] || Blockly.Themes.Classic,
                    fontStyle: fontStyle,
                    componentStyles: themeSettings.componentStyles,
                    blockStyles: themeSettings.blockStyles
                });
            } else {
                console.error('No theme settings found in JSON.');
            }

        }

        defineBlocks(blocks) {
            if (!blocks || blocks.length === 0) {
                throw new Error('No blocks found in JSON.');
            }

            blocks.forEach(block => {
                Blockly.common.defineBlocksWithJsonArray([{...block}]);

                javascript.javascriptGenerator.forBlock[block.type] = (blockInstance) => {
                    const id = blockInstance.id;
                    const code = block.javascript_function || "";
                    if (block.type === 'run_event') {
                        return `await this.highlightBlock("${id}");\n${code}`;
                    } else {
                        return code;
                    }
                };
            });
            javascript.javascriptGenerator.forBlock['repeat_loop_K_2'] = function (block) {
                let times = block.getFieldValue('TIMES') || 10;
                let innerCode = javascript.javascriptGenerator.statementToCode(block, 'DO');
                return `
        for (let i = 0; i < ${times}; i++) {
            ${innerCode}
        }
        `;
            };

            javascript.javascriptGenerator.forBlock['repeat_loop_2_5'] = function (block) {
                let times = block.getFieldValue('TIMES') || 10;
                let innerCode = javascript.javascriptGenerator.statementToCode(block, 'DO');
                return `
        for (let i = 0; i < ${times}; i++) {
            ${innerCode}
        }
        `;
            };

            javascript.javascriptGenerator.forBlock["turn"] = function (block) {
                const direction = block.getFieldValue("DIRECTION");
                const id = block.id;
                return `await this.highlightBlock("${id}");\nawait this.turnTo("${direction}");\n`;
            };

            javascript.javascriptGenerator.forBlock["move_choice_action"] = function (block) {
                const direction = block.getFieldValue("DIRECTION");
                const id = block.id;
                return `await this.highlightBlock("${id}");\nawait this.move_choice_action("${direction}");\n`;
            };

        }

        createToolbox(blocks) {
            this.toolbox = {
                'kind': 'flyoutToolbox',
                'contents': blocks.map(block => ({'kind': 'block', 'type': block.type}))
            };
        }

        injectWorkspace() {
            this.workspace = Blockly.inject(this.blocklyDiv, {
                toolbox: this.toolbox,
                theme: this.customTheme,
                trashcan: true,

                // Scroll, drag, and wheel behavior
                move: {
                    scrollbars: {
                        horizontal: true,
                        vertical: true
                    },
                    drag: true,
                    wheel: true
                },

                // Zoom behavior
                zoom: {
                    controls: true,         // show zoom in/out buttons
                    wheel: true,            // allow mouse wheel zoom
                    startScale: 1.0,        // initial zoom scale
                    maxScale: 3.0,          // max zoom
                    minScale: 0.3,          // min zoom
                    scaleSpeed: 1.2         // zoom speed
                },

                // Grid setup
                grid: {
                    spacing: 20,            // pixels between grid lines
                    length: 1,              // line length (0 = no lines)
                    colour: '#ccc',         // grid line color
                    snap: true              // snap blocks to grid
                },

                // Path to Blockly media assets (like sounds, icons)
                //media: 'https://unpkg.com/blockly/media/',

                // Renderer (default: "geras", others: "zelos", "thrasos")
                renderer: 'geras',

                // Font and text direction options
                rtl: false,                // right-to-left mode
                fontFamily: 'Arial, sans-serif',

                // Sounds (on/off)
                sounds: true,

                // Collapse blocks option
                collapse: true,

                // Comments enabled
                comments: true,

                // Disable blocks
                disable: true,

                // Scrollbars visible even without overflow
                scrollbars: true,

                // Max blocks (set to null for no limit)
                maxBlocks: Infinity,

                // Optional: inject plugins here
                // plugins: {}
            });
        }

        countAttachedBlocks(block) {
            if (!block) return 0;

            let count = 1; // Count this block

            // Go through each input (statement, value, dummy)
            for (const input of block.inputList) {
                const connected = input.connection?.targetBlock();
                if (connected) {
                    count += this.countAttachedBlocks(connected);
                }
            }

            // Also go through the next block in the sequence (outside of inputs)
            const nextBlock = block.getNextBlock();
            if (nextBlock) {
                count += this.countAttachedBlocks(nextBlock);
            }

            return count;
        }


        setupChangeListener() {
            const updateCapacity = () => {
                const allBlocks = this.workspace.getAllBlocks();
                const runEventBlock = allBlocks.find(block => block.type === 'run_event');
                let usedBlocks = 0;
                if (runEventBlock) {
                    usedBlocks = this.countAttachedBlocks(runEventBlock);
                }

                const remaining = this.maxBlocks - usedBlocks;

                numberBlockCapacityElement.textContent = Math.abs(remaining).toString();

                if (remaining < 0) {
                    buttonCapacityElement.classList.remove("btn-primary");
                    buttonCapacityElement.classList.add("btn-warning");
                    contentBlockCapacityElement.textContent = "over";
                } else {
                    buttonCapacityElement.classList.remove("btn-warning");
                    buttonCapacityElement.classList.add("btn-primary");
                    contentBlockCapacityElement.textContent = "left";
                }
            };
            // Initial capacity update
            this.workspace.addChangeListener(updateCapacity);
            updateCapacity(); // initial run
        }


        setupResizeObserver() {
            if (!buttonVisualisationElement) {
                console.error("ResizeObserver error: visualisation element not found.");
                return;
            }

            const resizeObserver = new ResizeObserver(() => {
                this.resizeBlocklyWorkspace();
            });

            resizeObserver.observe(buttonVisualisationElement);
        }

        // Resizes the Blockly workspace
        resizeBlocklyWorkspace() {
            if (this.workspace) {
                Blockly.svgResize(this.workspace);
            }
        }


    }


    class Sprite {
        static listOfSprites = [];
        static #numberOfEnvironmentSprites = 0;
        static _directions = ['west', 'north', 'east', 'south'];

        constructor(imageURL, row, col, direction, showNotification = false, notificationNumber = 0, gridSize, app, activity) {
            this.row = row;
            this.col = col;
            this._gridSize = gridSize;
            this.showNotif = showNotification;
            this.activity = activity;
            this.notif_number = notificationNumber;
            this.app = app;
            this.original_notif_number = notificationNumber;
            this.direction = direction;
            this.originalDirection = direction;
            this.sprite = PIXI.Sprite.from(imageURL);
            this.sprite.anchor.set(0.5);
            this.directionToAngle = {
                east: 0,
                south: Math.PI / 2,
                west: Math.PI,
                north: -Math.PI / 2,
            };
            this.sprite.rotation = this.directionToAngle[this.originalDirection] || 0;
            this.updateSizeAndPosition();
            Object.defineProperty(this, "originalRow", {
                value: row,
                writable: false, // Prevent modification
                configurable: false, // Prevent redefinition
            });
            Object.defineProperty(this, "originalCol", {
                value: col,
                writable: false, // Prevent modification
                configurable: false, // Prevent redefinition
            });
            this.container = new PIXI.Container();
            this.container.addChild(this.sprite);

            if (this.showNotif) {
                this.notifText = new PIXI.Text(this.notif_number, {
                    fontFamily: 'Arial',
                    fontSize: 14,
                    fill: 'yellow',
                    fontWeight: 'bold',
                    stroke: 'black',
                    strokeThickness: 4
                });
                this.notifText.anchor.set(0.5);
                this.container.addChild(this.notifText);
                this.updateNotificationPosition();
            }

            this.app.stage.addChild(this.container);
            Sprite.listOfSprites.push(this);
            Sprite.#numberOfEnvironmentSprites += notificationNumber;
        }

        static restoreNotificationNumberForAllSprites() {
            Sprite.#numberOfEnvironmentSprites = 0;
            this.listOfSprites.forEach(sprite => Sprite.#numberOfEnvironmentSprites += sprite.original_notif_number);
        }

        notify(newNumber) {
            if (this.showNotif && this.notifText) {
                this.notif_number = newNumber;
                this.notifText.text = newNumber;
            }
        }

        static decreaseNumberOfEnvironmentSprites() {
            Sprite.#numberOfEnvironmentSprites--;

        }

        static hasEnvironmentSprites() {
            return Sprite.#numberOfEnvironmentSprites !== 0;
        }

        static getNumberOfEnvironmentSprites() {
            return Sprite.#numberOfEnvironmentSprites;
        }


        initialize() {
            this.row = this.originalRow;
            this.col = this.originalCol;
            this.updateSizeAndPosition();
            if (this.showNotif) {
                this.updateNotificationPosition();
            }
            this.direction = this.originalDirection;
            this.sprite.rotation = this.directionToAngle[this.direction] || 0;
        }


        resize(gridSize) {
            if (!this.sprite || !this.sprite.texture || !this.sprite.texture.baseTexture.valid) {
                console.warn("Sprite is not ready for resizing");
                return;
            }
            if (!this.sprite || !this.container) {
                console.warn("Sprite or container is not initialized.");
                return;
            }

            this._gridSize = gridSize;

            // Resize sprite
            this.sprite.width = this.sprite.height = gridSize;

            // Reposition sprite
            this.sprite.x = this.col * gridSize + gridSize / 2;
            this.sprite.y = this.row * gridSize + gridSize / 2;

            // Reposition notification text, if it exists
            if (this.showNotif && this.notifText) {
                this.notifText.x = this.sprite.x + gridSize / 3;
                this.notifText.y = this.sprite.y - gridSize / 3;
            }

            // Add container back to stage if it's missing
            if (this.app && this.app.stage && !this.app.stage.children.includes(this.container)) {
                this.app.stage.addChild(this.container);
            }
        }


        updateSizeAndPosition() {
            this.sprite.width = this.sprite.height = this._gridSize;
            this.sprite.x = this.col * this._gridSize + this._gridSize / 2;
            this.sprite.y = this.row * this._gridSize + this._gridSize / 2;
        }

        updateNotificationPosition() {
            this.notifText.x = this.sprite.x + this._gridSize / 3;
            this.notifText.y = this.sprite.y - this._gridSize / 3;
        }

        hide() {
            this.container.visible = false;
        }

        show() {
            this.container.visible = true;
        }


    }

    class Player extends Sprite {
        static listOfPlayers = [];

        constructor(...args) {
            super(...args); // Pass all arguments to the parent class constructor
            Player.listOfPlayers.push(this);
        }

        moveSmoothly(newRow, newCol, speed, isRunning, callback) {
            let targetX = newCol * this._gridSize + this._gridSize / 2;
            let targetY = newRow * this._gridSize + this._gridSize / 2;

            const animateMove = () => {
                if (!isRunning) {
                    this.sprite.x = targetX; // Snap to final position
                    this.sprite.y = targetY;
                    return;
                }
                let dx = targetX - this.sprite.x;
                let dy = targetY - this.sprite.y;

                if (Math.abs(dx) > 1 || Math.abs(dy) > 1) {
                    this.sprite.x += dx / speed;
                    this.sprite.y += dy / speed;
                    requestAnimationFrame(animateMove);
                } else {
                    this.sprite.x = targetX;
                    this.sprite.y = targetY;
                    this.row = newRow;
                    this.col = newCol;
                    if (typeof callback === "function") callback();
                }
            };

            requestAnimationFrame(animateMove);
        }

        moveSmoothlyHalfStep(newRow, newCol, speed, isRunning, callback) {
            // Adjust target position to move only 0.5 tile forward
            let currentX = this.sprite.x;
            let currentY = this.sprite.y;

            let fullTargetX = newCol * this._gridSize + this._gridSize / 2;
            let fullTargetY = newRow * this._gridSize + this._gridSize / 2;

            // Compute direction vector
            let dx = fullTargetX - currentX;
            let dy = fullTargetY - currentY;

            // Normalize direction vector
            let length = Math.sqrt(dx * dx + dy * dy);
            let unitX = dx / length;
            let unitY = dy / length;

            // Move only 0.5 grid unit in that direction
            let halfStepDistance = this._gridSize * 0.5;
            let targetX = currentX + unitX * halfStepDistance;
            let targetY = currentY + unitY * halfStepDistance;

            const animateMove = () => {
                if (!isRunning) {
                    this.sprite.x = targetX;
                    this.sprite.y = targetY;
                    return;
                }
                let dx = targetX - this.sprite.x;
                let dy = targetY - this.sprite.y;

                if (Math.abs(dx) > 1 || Math.abs(dy) > 1) {
                    this.sprite.x += dx / speed;
                    this.sprite.y += dy / speed;
                    requestAnimationFrame(animateMove);
                } else {
                    this.sprite.x = targetX;
                    this.sprite.y = targetY;
                    if (typeof callback === "function") callback();
                }
            };

            requestAnimationFrame(animateMove);
        }

        moveBy(deltaCol, deltaRow, map_layout, speed, isRunning, callback) {
            let newRow = this.row + deltaRow;
            let newCol = this.col + deltaCol;
            let rowKey = Object.keys(map_layout)[newRow];
            let colKey = Object.keys(map_layout[rowKey])[newCol];

            if (map_layout[rowKey] && map_layout[rowKey][colKey] !== undefined &&
                (map_layout[rowKey][colKey] === 1)) {
                this.moveSmoothly(newRow, newCol, speed, isRunning, callback);
            } else {
                this.moveSmoothlyHalfStep(newRow, newCol, speed, isRunning, callback);
                Activity.playSound(Activity.activityTypeGameSettings.sounds.failed);
                this.activity.addOverlay("Crashed!!", 0xE30000)
            }
        }

        async turnAnimatedTo(direction, speed, isRunning, callback) {
            if (!isRunning) {
                return; // Don't proceed if isRunning is false
            }

            const rawSpeed = parseInt(speed);
            const adjustedSpeed = Math.min(Math.max(rawSpeed, 1), 10) / 100;

            // Normalize current rotation to [0, 2Ï€)
            this.sprite.rotation = (this.sprite.rotation + 2 * Math.PI) % (2 * Math.PI);

            // Calculate target rotation
            let targetRotation;
            if (direction === "right") {
                targetRotation = (this.sprite.rotation + Math.PI / 2) % (2 * Math.PI);
            } else if (direction === "left") {
                targetRotation = (this.sprite.rotation + 3 * Math.PI / 2) % (2 * Math.PI); // = -90Â°
            } else {
                console.warn("Invalid direction:", direction);
                return;
            }

            return new Promise(resolve => {
                const rotateStep = () => {
                    if (!isRunning) {
                        return; // Stop the rotation if isRunning becomes false
                    }

                    let diff = targetRotation - this.sprite.rotation;

                    if (diff > Math.PI) diff -= 2 * Math.PI;
                    if (diff < -Math.PI) diff += 2 * Math.PI;

                    if (Math.abs(diff) < 0.01) {
                        this.sprite.rotation = targetRotation;
                        if (callback) callback();
                        resolve();
                        return;
                    }

                    this.sprite.rotation += adjustedSpeed * Math.sign(diff);
                    requestAnimationFrame(rotateStep);
                };

                rotateStep();
            });
        }

        async turnTo(turnDirection, speed, isRunning, callback) {
            if (!isRunning) return;

            const directions = this.constructor._directions;
            let currentIndex = directions.indexOf(this.direction);

            const angle = Math.PI / 2;

            if (turnDirection === "left") {
                this.sprite.rotation -= angle;
                currentIndex = (currentIndex + 3) % 4; // turning left = -1
            } else if (turnDirection === "right") {
                this.sprite.rotation += angle;
                currentIndex = (currentIndex + 1) % 4; // turning right = +1
            } else {
                console.warn("Invalid turnDirection:", turnDirection);
                return;
            }

            // Update logical direction
            this.direction = directions[currentIndex];

            // Normalize rotation to [0, 2Ï€)
            this.sprite.rotation = (this.sprite.rotation + 2 * Math.PI) % (2 * Math.PI);

            // Optional: add timeout to simulate delay based on speed
            const clampedSpeed = Math.min(Math.max(parseInt(speed), 1), 10);
            const delay = 1000 / clampedSpeed;

            setTimeout(() => {
                if (typeof callback === "function") callback();
            }, delay);
        }


        async getPerson(activity, callback) {
            let person = activity.people.find(p => this.isNextTo(p) && p.notif_number !== 0);

            if (person) {

                Activity.playSound(Activity.activityTypeGameSettings.sounds.succeeded);

                if (person.notif_number > 1) {
                    activity.giveHint("Removed 1 person", "3000");
                    await new Promise(resolve => setTimeout(resolve, activity.speed * 100));
                    Sprite.decreaseNumberOfEnvironmentSprites();
                    person.notify(person.notif_number - 1);
                } else if (person.notif_number === 1) {
                    activity.giveHint("Everyone is inside", "3000");
                    await new Promise(resolve => setTimeout(resolve, activity.speed * 100));
                    Sprite.decreaseNumberOfEnvironmentSprites();
                    person.notify(0);
                    person.hide();
                }

                if (typeof callback === "function") await callback(person);

                // After potentially removing someone, check if that was the last
                if (!Sprite.hasEnvironmentSprites()) {
                    await new Promise(resolve => setTimeout(resolve, activity.speed * 100));
                    await activity.levelCompleted();
                }

                return person;
            } else {
                // No person found
                if (Sprite.hasEnvironmentSprites()) {
                    activity.giveHint("No person to be picked up", "3000");
                    activity.hasFailed();
                } else {
                    // No environment sprites left
                    await new Promise(resolve => setTimeout(resolve, activity.speed * 100));
                    await activity.levelCompleted();
                }

                if (typeof callback === "function") await callback(null);
                return null;
            }
        }


        isNextTo(otherSprite) {
            if (!otherSprite) return false; // Prevent errors if null
            const dRow = Math.abs(this.row - otherSprite.row);
            const dCol = Math.abs(this.col - otherSprite.col);
            return (dRow === 1 && dCol === 0) || (dRow === 0 && dCol === 1);
        }


        async getBook(activity, callback) {
            if (!Sprite.hasEnvironmentSprites()) {
                await new Promise(resolve => setTimeout(resolve, activity.speed * 100)); // 0.5 sec delay
                await activity.levelCompleted();
            }
            let book = activity.books.find(b => this.isOnto(b) && b.notif_number !== 0);
            if (book) {
                if (book.notif_number > 1) {
                    Activity.playSound(Activity.activityTypeGameSettings.sounds.succeeded);
                    activity.giveHint("Removed 1 person", "3000");
                    await new Promise(resolve => setTimeout(resolve, activity.speed * 100)); // 0.5 sec delay
                    Sprite.decreaseNumberOfEnvironmentSprites();
                    person.notify(book.notif_number - 1);
                } else if (book.notif_number === 1) {
                    Activity.playSound(Activity.activityTypeGameSettings.sounds.succeeded);
                    activity.giveHint("Everyone is inside", "3000");
                    book.notify(book.notif_number - 1);
                    await new Promise(resolve => setTimeout(resolve, activity.speed * 100)); // 0.5 sec delay
                    Sprite.decreaseNumberOfEnvironmentSprites();
                    book.notify(book.notif_number - 1);
                    book.hide();
                } else if (person.notif_number <= 0) {
                    activity.giveHint("No person to be picked up", "3000");
                    activity.hasFailed();
                }
                if (typeof callback === "function") await callback(book);
                return book;
            } else {
                activity.hasFailed();
                activity.giveHint("No person to be picked up", "150000");
            }

            if (typeof callback === "function") await callback(null);
            return null;
        }

        isOnto(otherSprite) {
            if (!otherSprite) return false; // Prevent errors if null

            const dRow = Math.abs(this.row - otherSprite.row);
            const dCol = Math.abs(this.col - otherSprite.col);
            console.log(`Checking next-to: this (${this.row}, ${this.col}) vs other (${otherSprite.row}, ${otherSprite.col}) â†’ dRow: ${dRow}, dCol: ${dCol}`);

            return (dRow === 1 && dCol === 0) || (dRow === 0 && dCol === 1);
        }
    }


    document.addEventListener('DOMContentLoaded', () => {
        // Sidebar collapse behavior
        $('#sidebarMenu .collapse').on('show.bs.collapse', function () {
            $('#sidebarMenu .collapse').not(this).collapse('hide');
        });

        // Change background of active dropdown
        $('#sidebarMenu .dropdown-toggle').on('click', function () {
            $sidebarItems.removeClass('active-bg-sidebar').addClass('bg-sidebar');
            $(this).parent().removeClass('bg-sidebar').addClass('active-bg-sidebar');
        });
        // Animate grade cards
        gsap.from(".grade-card", {
            duration: 0.8,
            opacity: 0,
            stagger: 0.05,
            ease: "power1.out"
        });
    });


    function toggleMenu() {
        let sidebar = document.getElementById("sidebar");
        let overlay = document.getElementById("overlay");
        sidebar.classList.toggle("show");
        overlay.classList.toggle("show");
    }


    async function init(type, level) {
        new Activity(type, level);
        buttonNextLevelElements.forEach(button => {
            button.addEventListener("click", function () {
                setNextLevel();
            });
        });
    }

    function reloadWindow() {
        window.open("{{link}}", '_top');
    }


    soundButtonElement.addEventListener("click", () => {
        if (window.backgroundMusic && window.backgroundMusic.paused) {
            soundButtonElement.innerHTML = '<i class="fa-solid fa-volume-high"></i>';
            window.backgroundMusic.play().catch(err => {
                console.warn("Playback failed:", err);
            });
        } else {
            window.backgroundMusic.pause();
            soundButtonElement.innerHTML = '<i class="fa-solid fa-volume-xmark"></i>';
        }
    });


    function showPane(paneId) {
        // Hide all panes and reset z-index and pointer events
        document.querySelectorAll('.tab-pane').forEach(pane => {
            pane.style.display = 'none';
            pane.style.zIndex = '0';
            pane.style.pointerEvents = 'none';
            pane.style.backgroundColor = ''; // Reset background color for other panes
        });

        // Show the target pane and add the necessary styles
        const targetPane = document.getElementById(paneId);
        targetPane.style.display = 'flex'; // or 'block', based on layout
        targetPane.style.zIndex = '1';
        targetPane.style.pointerEvents = 'auto';

        // Specific style for the home pane (white background)
        if (paneId === 'home') {
            targetPane.style.backgroundColor = 'white'; // Add white background
            if (window.backgroundMusic && !window.backgroundMusic.paused) {
                window.backgroundMusic.pause();
            }
        }

        if (paneId === 'codingPane') {
            if (window.backgroundMusic && window.backgroundMusic.paused) {
                window.backgroundMusic.play().catch(err => {
                    console.warn("Playback failed:", err);
                });
            }
        }

        // If loadingPane is showing, animate loading text
        if (paneId === 'loadingPane') {
            gsap.fromTo("#loadingText",
                {opacity: 0, y: 10},
                {opacity: 1, y: 0, duration: 0.6, ease: "power2.out", repeat: -1, yoyo: true}
            );
        } else {
            // Stop animation and hide success text for other panes
            gsap.killTweensOf("#loadingText");
            document.getElementById('successText').style.display = 'none';
        }
    }

    function handleLoginStatus(isLoggedIn) {
        try {
            gsap.killTweensOf("#loadingText");
        } catch (err) {
            console.warn("âš ï¸ Failed to kill loading animation:", err);
        }

        const spinner = document.querySelector(".spinner-border");
        if (spinner) {
            spinner.style.display = "none";
        }

        const successText = document.getElementById("successText");
        const errorText = document.getElementById("loadingText");

        if (isLoggedIn) {
            if (successText) {
                successText.style.display = "block";
                successText.style.opacity = '0';

                gsap.fromTo(successText,
                    {opacity: 0, y: 20},
                    {
                        opacity: 1,
                        y: 0,
                        duration: 0.8,
                        ease: "power3.out",
                        onStart: () => console.log("ðŸŽ‰ Showing success text"),
                        onComplete: () => console.log("âœ… Success text animation complete")
                    }
                );
            } else {
                console.error("âŒ successText element not found!");
            }

            // Hide error message if any
            if (errorText) {
                errorText.style.display = "none";
            }
            showPane('home');

        } else {
            // Show error message for login failure
            if (errorText) {
                errorText.innerHTML = `Login Failed. <br>Please log in with your Google Account. <br><a href="https://accounts.google.com/ServiceLogin" target="_blank">Log in here</a>`;
                errorText.style.display = "block"; // Show error message

                gsap.fromTo(errorText,
                    {opacity: 0, y: 10},
                    {
                        opacity: 1,
                        y: 0,
                        duration: 0.8,
                        ease: "power3.out",
                        onStart: () => console.log("ðŸš¨ Showing error text"),
                        onComplete: () => console.log("âŒ Error text animation complete")
                    }
                );
            } else {
                console.error("âŒ loadingText element not found!");
            }

            // Hide success message if any
            if (successText) {
                successText.style.display = "none";
            }
        }
    }

    document.querySelectorAll('.link-container').forEach(function (container) {
        container.addEventListener('click', function (event) {
            const link = event.target.closest('.nav-link, .exercise-link');
            if (link) {
                event.preventDefault();
                const param = link.getAttribute('data-param');
                setNextLesson(param, "1");
            }
        });
    });

    function setNextLesson(type, level) {
        sessionStorage.setItem("currentLessonType", type);
        sessionStorage.setItem("currentLessonLevel", level);
        sessionStorage.setItem("setNextLesson", "true");
        reloadWindow();
    }

    function setNextLevel() {
        let nextLevel = Number(sessionStorage.getItem("currentLessonLevel")) + 1;
        sessionStorage.setItem("currentLessonLevel", nextLevel.toString());
        sessionStorage.setItem("setNextLevel", "true");
        reloadWindow();
    }

    function renderProgressBar(type) {
        const container = document.querySelector('.progress-container');
        container.innerHTML = '';
        const studentProgress = JSON.parse(sessionStorage.getItem("studentProgress"));
        if (studentProgress[type]) {
            const levels = studentProgress[type];
            for (const level in levels) {
                const div = document.createElement('div');

                let colorClass = levels[level] ? 'bg-success' : 'bg-secondary';

                div.className = `rounded-circle progress-dot ${colorClass}`;

                if (sessionStorage.getItem("currentLessonLevel") === level) {
                    div.classList.add('current-level');
                    div.textContent = level;
                }

                div.addEventListener('click', () => {
                    setNextLesson(type, level);
                });

                container.appendChild(div);
            }
        }
    }

    // Disable all clickable links and buttons
    function disableLinks() {
        // Disable anchor links
        const links = document.querySelectorAll('a, button, select');
        links.forEach(link => {
            link.style.pointerEvents = 'none'; // Disable clicking
            link.style.opacity = '0.5'; // Visual indication of being disabled
        });
    }

    // Enable all clickable links and buttons
    function enableLinks() {
        // Enable anchor links
        const links = document.querySelectorAll('a, button, select');
        links.forEach(link => {
            link.style.pointerEvents = ''; // Enable clicking
            link.style.opacity = ''; // Remove the disabled opacity
        });
    }

    document.getElementById("homeLink").addEventListener("click", function (event) {
        event.preventDefault();
        showPane("home");
    });


</script>
</body>
</html>