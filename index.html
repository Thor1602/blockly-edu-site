<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blockly by Mr. Thorben</title>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css"
          integrity="sha512-Evv84Mr4kqVGRNSgIGL/F/aIDqQb7xQ2vcrdIwxfjThSH8CSR7PBEakCr51Ck+w+/U6swU2Im1vVX0SVk9ABhg=="
          crossorigin="anonymous" referrerpolicy="no-referrer"/>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.5.1/gsap.min.js"></script>
    <script src="https://unpkg.com/blockly/blockly_compressed.js"></script>
    <script src="https://unpkg.com/blockly/blocks_compressed.js"></script>
    <script src="https://unpkg.com/blockly/javascript_compressed.js"></script>
    <script src="https://unpkg.com/blockly/msg/en.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.1.3/pixi.min.js"></script>
    <script src="https://w.soundcloud.com/player/api.js"></script> <!-- Load SoundCloud API -->

    <script>
        function loadUser() {
            google.script.run.withSuccessHandler(function(email) {
                document.getElementById("activeUser").innerText = "Logged in as: " + email;
            }).getUserEmail();
        }
    </script>
    <style>
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: none; /* Hidden initially */
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        body {
            overflow: hidden;
            padding: 0;
        }

        body, html {
            height: 100%;
            margin: 0;
        }

        .right-content {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .right-content .row {
            width: 100%;
        }

        /* ... (other styles) ... */
        .flex-container {
            display: flex;
            height: 100vh;
        }

        .flex-item-left { /* New class for the left item */
            flex: 0 0 33%; /* Takes 33% of the width */
        }

        .flex-item-right { /* New class for the right item */
            flex: 0 0 66%; /* Takes 66% of the width */
        }

        .btn-primary {
            background-color: #FF9800 !important;
            color: white !important;
            border-color: #FF9800 !important;
        }

        .btn-primary:hover,
        .btn-primary:visited,
        .btn-primary:active,
        .btn-primary:focus {
            background-color: #FF9800 !important;
            color: white !important;
            border-color: #FF9800 !important;
            box-shadow: none !important; /* Remove Bootstrap focus shadow */
        }

        .btn-primary:hover {
            box-shadow: 0 0 10px black !important; /* Adds black glow effect */
        }


        .btn-reset {
            background-color: #7200c3 !important;
            color: white !important;
            border-color: #7200c3 !important;
            display: none;
        }

        .btn-reset:hover,
        .btn-reset:visited,
        .btn-reset:active,
        .btn-reset:focus {
            background-color: #7200c3 !important;
            color: white !important;
            border-color: #7200c3 !important;
            box-shadow: none !important; /* Remove Bootstrap focus shadow */
        }

        .btn-reset:hover {
            box-shadow: 0 0 10px black !important; /* Adds black glow effect */
        }

        .pre-hint-container{
            height: 25px;
        }
        .hint-container{
            margin-left: 20px;
            height: 25px;
            background-color: white;
            color: black;
            padding-left: 20px;
            padding-right: 20px;
            border-radius: 20px;
        }
        /* styling for nav bar START */
        .offcanvas {
            position: fixed;
            top: 0;
            left: -250px; /* Initially hidden */
            width: 250px;
            height: 100%;
            background-color: #886500; /* yellow theme */
            color: white;
            overflow-y: auto;
            transition: 0.3s ease-in-out;
            padding-top: 60px;
            z-index: 1050; /* Above everything */
        }
        .offcanvas.show {
            left: 0; /* Slide in */
        }
        .offcanvas a {
            color: white;
            padding: 10px;
            display: block;
            text-decoration: none;
        }
        .offcanvas a:hover {
            background-color: #8c6c0d; /* yellow theme */
        }
        .close-btn {
            position: absolute;
            top: 10px;
            right: 20px;
            font-size: 24px;
            cursor: pointer;
        }

        /* Dark overlay when menu opens */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1045; /* Just below the sidebar */
            display: none; /* Hidden by default */
        }
        .overlay.show {
            display: block; /* Show when menu opens */
        }

        /* Navbar */
        .navbar {
            position: relative; /* No overlapping */
            z-index: 1030; /* Lower than sidebar */
        }

        /* Content */
        .content {
            padding: 20px;
        }
        .active-bg-sidebar {
            background-color: #8c6c0d; /* yellow theme */
        }
        .bg-sidebar {
            background-color: #886500; /* yellow theme */
        }
        /* styling for nav bar END */

    </style>

</head>
<body onload="loadUser()">

<nav class="navbar navbar-dark bg-warning">
    <div class="container-fluid">
        <!-- Hamburger Button -->
        <button class="navbar-toggler" type="button" onclick="toggleMenu()">
            <span class="navbar-toggler-icon"></span>
        </button>
        <select class="form-select form-select-lg mb-3" aria-label=".form-select-lg example" id="visualisationSize">
            <option selected disabled>Game Size</option>
            <option value="small">Small</option>
            <option value="medium">Medium</option>
            <option value="large">Large</option>
        </select>
        <a class="navbar-brand ml-3" href="#">Seoul Academy Apgujeong</a>
        <a class="nav-link disabled" id="activeUser"></a>
        <img src="https://postimg.cc/3d3VySKB"  height="40px" width="40px" alt=""/>

    </div>
</nav>

<!-- Dark Overlay (Shades Background) -->
<div id="overlay" class="overlay" onclick="toggleMenu()"></div>

<!-- Offcanvas Sidebar Menu -->
<div id="sidebar" class="offcanvas">
    <span class="close-btn" onclick="toggleMenu()">&times;</span>
    <ul class="nav flex-column" id="sidebarMenu">
        <!-- Grades with Submenus -->
        <li class="nav-item">
            <a href="#" class="nav-link dropdown-toggle" data-toggle="collapse" data-target="#kinderMenu" data-parent="#sidebarMenu">Kinder</a>
            <div id="kinderMenu" class="collapse">
                <a href="#" class="nav-link pl-4">Sequencing</a>
                <div class="pl-5">
                    <a href="#" class="nav-link" data-toggle="modal" data-target="#warningModal">Mr. Cab Driver 1</a>
                    <a href="#" class="nav-link">Mr. Cab Driver 2</a>
                    <a href="#" class="nav-link">Mr. Cab Driver 3</a>
                </div>
                <a href="#" class="nav-link pl-4">Loops</a>
                <a href="#" class="nav-link pl-4">Events</a>
            </div>
        </li>
        <li class="nav-item">
            <a href="#" class="nav-link dropdown-toggle" data-toggle="collapse" data-target="#grade1Menu" data-parent="#sidebarMenu">Grade 1</a>
            <div id="grade1Menu" class="collapse">
                <a href="#" class="nav-link pl-4">Sequencing</a>
                <div class="pl-5">
                    <a href="#" class="nav-link">Mr. Cab Driver 1</a>
                    <a href="#" class="nav-link">Mr. Cab Driver 2</a>
                    <a href="#" class="nav-link">Mr. Cab Driver 3</a>
                </div>
                <a href="#" class="nav-link pl-4">Loops</a>
                <a href="#" class="nav-link pl-4">Events</a>
            </div>
        </li>
        <li class="nav-item">
            <a href="#" class="nav-link dropdown-toggle" data-toggle="collapse" data-target="#grade2Menu" data-parent="#sidebarMenu">Grade 2</a>
            <div id="grade2Menu" class="collapse">
                <a href="#" class="nav-link pl-4">Sequencing</a>
                <div class="pl-5">
                    <a href="#" class="nav-link">Mr. Cab Driver 1</a>
                    <a href="#" class="nav-link">Mr. Cab Driver 2</a>
                    <a href="#" class="nav-link">Mr. Cab Driver 3</a>
                </div>
                <a href="#" class="nav-link pl-4">Loops</a>
                <a href="#" class="nav-link pl-4">Events</a>
            </div>
        </li>
        <li class="nav-item">
            <a href="#" class="nav-link dropdown-toggle" data-toggle="collapse" data-target="#grade3Menu" data-parent="#sidebarMenu">Grade 3</a>
            <div id="grade3Menu" class="collapse">
                <a href="#" class="nav-link pl-4">Sequencing</a>
                <div class="pl-5">
                    <a href="#" class="nav-link">Mr. Cab Driver 1</a>
                    <a href="#" class="nav-link">Mr. Cab Driver 2</a>
                    <a href="#" class="nav-link">Mr. Cab Driver 3</a>
                </div>
                <a href="#" class="nav-link pl-4">Loops</a>
                <a href="#" class="nav-link pl-4">Events</a>
            </div>
        </li>
        <li class="nav-item">
            <a href="#" class="nav-link dropdown-toggle" data-toggle="collapse" data-target="#grade4Menu" data-parent="#sidebarMenu">Grade 4</a>
            <div id="grade4Menu" class="collapse">
                <a href="#" class="nav-link pl-4">Sequencing</a>
                <div class="pl-5">
                    <a href="#" class="nav-link">Mr. Cab Driver 1</a>
                    <a href="#" class="nav-link">Mr. Cab Driver 2</a>
                    <a href="#" class="nav-link">Mr. Cab Driver 3</a>
                </div>
                <a href="#" class="nav-link pl-4">Loops</a>
                <a href="#" class="nav-link pl-4">Events</a>
            </div>
        </li>
        <li class="nav-item">
            <a href="#" class="nav-link dropdown-toggle" data-toggle="collapse" data-target="#grade5Menu" data-parent="#sidebarMenu">Grade 5</a>
            <div id="grade5Menu" class="collapse">
                <a href="#" class="nav-link pl-4">Sequencing</a>
                <div class="pl-5">
                    <a href="#" class="nav-link">Mr. Cab Driver 1</a>
                    <a href="#" class="nav-link">Mr. Cab Driver 2</a>
                    <a href="#" class="nav-link">Mr. Cab Driver 3</a>
                </div>
                <a href="#" class="nav-link pl-4">Loops</a>
                <div class="pl-5">
                    <a href="#" class="nav-link">Step 1</a>
                    <a href="#" class="nav-link">Step 2</a>
                    <a href="#" class="nav-link">Step 3</a>
                </div>
                <a href="#" class="nav-link pl-4">Events</a>
            </div>
        </li>
    </ul>
</div>
<div class="container-fluid vh-100 d-flex flex-row content">
    <!-- Left Side (Visualization) -->
    <div class="d-flex flex-column p-4">
        <h2>Mr. Cab Driver</h2>
        <div id="visualisation" class="border rounded bg-light p-3"></div>
        <div class="mt-3 d-flex justify-content-between">
            <button class="btn btn-lg btn-primary" id="btnRun">
                <i class="fa-solid fa-play"></i> RUN
            </button>
            <button class="btn btn-lg btn-reset" id="btnReset">
                <i class="fa-solid fa-rotate-right"></i> RESET
            </button>
            <button class="btn btn-lg btn-primary" id="btnStep">
                <i class="fa-solid fa-forward-step"></i> STEP
            </button>
        </div>
        <label for="speed" class="form-label"></label>
        <input type="range" class="form-range" min="0" max="10" step="1" id="speed" style="display: none">
    </div>

    <div class="d-flex flex-column flex-grow-1 p-4">
        <div class="bg-warning p-3 sticky-top">
            <h2>Instructions
                <span><button class="btn btn-primary">
                    <i class="fa-solid fa-question"></i> HINT
                </button></span>
            </h2>
            <p>Pick up everyone! Remaining blocks: <b>You have <span id="capacity"></span> block(s) left.</b></p>
            <div class="d-flex align-items-center">
                <div class="pre-hint-container" id="hint"></div> <!-- Custom margin in pixels -->
            </div>
        </div>
        <div class="border rounded bg-white p-4 flex-grow-1 mt-3">
            <div id="blocklyDiv" style="height: 100%; width: 100%;"></div>
        </div>
    </div>
</div>
<!-- Warning Modal -->
<div class="modal fade" id="warningModal" tabindex="-1" role="dialog" aria-labelledby="warningModalLabel" aria-hidden="true">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="warningModalLabel">Warning</h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body">
                This level is in development.
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-primary" data-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>
<script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.bundle.min.js"></script>

<script>
    // function loadUser() {
    //     google.script.run.withSuccessHandler(function(email) {
    //         document.getElementById("activeUser").innerText = "Logged in as: " + email;
    //     }).getUserEmail();
    // }
    let configData = null; // Global variable to store JSON
    async function fetchData() {
        //let configData = <?= jsonData ?>;
        //console.log("Loaded configData:", configData);
        const response = await fetch('blocks.json'); // Adjust path as needed
        configData = await response.json();
    }

    buttonSpeedElement = document.getElementById('speed');
    buttonRunElement = document.getElementById("btnRun");
    buttonResetElement = document.getElementById("btnReset");
    buttonStepElement = document.getElementById("btnStep");
    buttonCapacityElement = document.getElementById("capacity");
    buttonVisualisationElement = document.getElementById("visualisation");
    buttonHintElement = document.getElementById("hint");
    blocklyDivElement = document.getElementById('blocklyDiv');
    visualisationSize = document.getElementById("visualisationSize");


    class Activity {
        constructor({name, instructions, gridSize, hints, mapLayout, sounds, blocks, goal, speedElement}) {
            this.name = name;
            this.mapLayout = mapLayout;
            this.instructions = instructions;
            this.hints = hints;
            this.sprites = [];  // Initialize as empty arrays
            this.people = [];   // Initialize as empty arrays
            this.sounds = sounds;
            this.player = null;
            this.blocks = blocks;
            this.blockManager = null;
            this.goal = goal;
            this.map = null; // Initialize as null and set it later asynchronously
            this.app = null; // Initialize as null
            this._gridSize = gridSize; // Initialize as null
            this.levelCompleted = false; // Initialize as null
            this.speed = 1;
            this.speedElement = speedElement;
            this.isRunning = false;

            this.overlayContainer = null;
            buttonRunElement.addEventListener("click", () => {
                this.runCode();
            });
            buttonResetElement.addEventListener("click", () => {
                this.resetCode();
            });
            // Initialize the activity asynchronously
            this.initializeActivity();
            this.initializeBlocklyWorkspace();
            this.addKeyInput(this.runCode, this.resetCode);
            this.visualisationDivSizeListener();
        }

        levelCompleted(){
            this.levelCompleted = true;
            this.hasSucceeded();
            console.log("Level Finished")
        }

        async initializeActivity() {
            if (this.speed) {
                this.speedElement.style.display = "inline-block";
                this.speed = this.speedElement.value;
                this.speedElement.oninput = () => this.speed = this.speedElement.value;
            }
            // Initialize the PIXI application first with default values
            this.app = new PIXI.Application({
                width: 12*this._gridSize, // Default placeholder values
                height: 16*this._gridSize, // Default placeholder values
                backgroundColor: 0xAAAAAA
            });

            // Initialize the map first
            this.map = await new MapLayout(this.mapLayout, false, this.app);
            await this.map.initialize(this.mapLayout);
            this.player = new Player('https://i.postimg.cc/8C5cQSb0/taxi.png', 9, 11, false, 0, this._gridSize, this.app);
            let positions = [
                // [2, 4, 3], [7, 5, 2], [8, 10,1],
                [6, 10,5], [5, 10,10]
            ];
            for (let pos of positions) {
                this.sprites.push(new Sprite('https://i.postimg.cc/wvRBMQZ5/person.png', pos[0], pos[1], true, pos[2], this._gridSize, this.app));
            }
            this.people = Sprite.listOfSprites.filter(item => !(item instanceof Player));
            this.sprites = Sprite.listOfSprites;
            // Append PIXI app view (canvas) to DOM
            buttonVisualisationElement.appendChild(this.app.view);

            this.initializeEnvironment();
            this.map.drawSprites(this.sprites);  // Pass the correct 'sprites' array
        }
        initializeEnvironment() {
            if (!this.map) {
                console.error("Map is not initialized yet.");
                return;
            }

            if (this.sprites) {
                this.sprites.forEach((sprite) => {
                    if (sprite) sprite.resize(this._gridSize);
                });
            }
            this.map.drawMap(this._gridSize);
        }
        visualisationDivSizeListener() {
            visualisationSize.addEventListener("change", () => {
                if (visualisationSize.value === "medium") {
                    this.resizeActivity(30);
                } else if (visualisationSize.value === "large") {
                    this.resizeActivity(40);
                } else if (visualisationSize.value === "small") {
                    this.resizeActivity(20);
                } else {
                    this.resizeActivity(30);
                }
            });
        }

        resizeActivity(newGridSize) {
            this._gridSize = newGridSize;

            // Resize all sprites (including player)
            if (this.sprites) {
                this.sprites.forEach(sprite => {
                    if (sprite) sprite.resize(newGridSize);
                });
            }

            // Resize player separately if needed
            if (this.player) {
                this.player.resize(newGridSize);
            }

            // Resize map (if you make a resize method in MapLayout)
            if (this.map) {
                this.map.drawMap(newGridSize);  // it uses internal gridSize
                this.map.drawSprites(this.sprites);
            }

            // Resize PIXI app view/canvas
            if (this.app) {
                this.app.renderer.resize(12 * newGridSize, 16 * newGridSize);
            }
        }

        hasSucceeded() {
            this.addOverlay("Challenge Completed!")
        }

        hasFailed() {
          this.addOverlay("ðŸ¤”")
        }

        addOverlay(message){
            if (!this.app || this.overlayContainer) return;
            // Create container for overlay elements
            this.overlayContainer = new PIXI.Container();
            // 1. Semi-transparent black rectangle
            const overlay = new PIXI.Graphics();
            overlay.beginFill(0x000000, 0.3); // 30% black
            overlay.drawRect(0, 0, this.app.screen.width, this.app.screen.height);
            overlay.endFill();
            this.overlayContainer.addChild(overlay);
            // 2. Centered "Try Again" text
            const textMessage = new PIXI.Text(message, {
                fontFamily: "Arial",
                fontSize: 48,
                fill: 0xffffff,
                align: "center"
            });
            textMessage.anchor.set(0.5);
            textMessage.x = this.app.screen.width / 2;
            textMessage.y = this.app.screen.height / 2;
            this.overlayContainer.addChild(textMessage);

            // Optional: Make overlay block interactions below
            this.overlayContainer.interactive = true;
            this.overlayContainer.interactiveChildren = false;

            // Add overlay to stage
            this.app.stage.addChild(this.overlayContainer);
        }

        removeOverlay() {
            if (this.overlayContainer) {
                this.app.stage.removeChild(this.overlayContainer);
                this.overlayContainer.destroy({ children: true });
                this.overlayContainer = null;
            }
        }


        resetActivity() {
            if (this.app) {
                this.app.destroy(true, { children: true });
                this.app = null;
            }

            // Reset everything
            this.map = null;
            this.player = null;
            this.people = [];
            this.sprites = [];

            // Also clear the canvas container (if reused)
            buttonVisualisationElement.innerHTML = "";
        }



        // what my sprites will do according to the blocks
        pick_up() {
            return new Promise(resolve => this.player.getPerson(this, this.people, this.speed, resolve));
        }

        move_north() {
            return new Promise(resolve => this.player.moveBy(0, -1, this.getMapLayout(), this.speed, this.isRunning, resolve));
        }

        move_south() {
            return new Promise(resolve => this.player.moveBy(0, 1, this.getMapLayout(), this.speed, this.isRunning, resolve));
        }

        move_west() {
            return new Promise(resolve => this.player.moveBy(-1, 0, this.getMapLayout(), this.speed, this.isRunning, resolve));
        }

        move_east() {
            return new Promise(resolve =>
                this.player.moveBy(1, 0, this.getMapLayout(), this.speed, this.isRunning, this.isRunning, resolve));
        }

        runCodeBlock() {
            return new Promise(resolve => {
                this.giveHint("The code has started RUNNING", "3000");
                resolve(); // Resolve immediately after showing the hint
            });
        }


        // Running Blockly Code
        async runCode() {
            if (this.isRunning) return; // Prevent multiple executions
            this.isRunning = true;
            this.player.initialize();
            buttonRunElement.style.display = "none";
            buttonResetElement.style.display = "inline-block";
            let runEventBlock = this.blockManager.workspace.getAllBlocks().find(block => block.type === 'run_event');
            if (!runEventBlock) {
                this.giveHint("Error: Run block is missing. Please add the Run block.", "15000");
                this.hasFailed();
                this.isRunning = false; // Allow execution again
                return;
            }
            this.playSound("d");
            javascript.javascriptGenerator.init(this.blockManager.workspace);
            let code = javascript.javascriptGenerator.blockToCode(runEventBlock);
            try {
                await eval(`(async () => {
                    let checkRunning = () => this.isRunning; // Closure to check the flag
                    ${code.split("await").join("if (!checkRunning()) return; await")} // Insert check before each await
                })();`);
            } catch (error) {
                console.error("Error executing code:", error);
            } finally {
                this.isRunning = false;
            }
        }


        resetCode() {

            this.isRunning = false;
            this.removeOverlay();
            // this.getMap().setGridSize();
            // this.initializeEnvironment();
            buttonResetElement.disabled = true;
            buttonStepElement.disabled = true;
            buttonRunElement.disabled = true;
            buttonResetElement.innerHTML = `
                    <span class="spinner-grow spinner-grow-sm" role="status" aria-hidden="true"></span>
                    LOAD
                `;
            buttonStepElement.innerHTML = `
                    <span class="spinner-grow spinner-grow-sm" role="status" aria-hidden="true"></span>
                    LOAD
                `;
            setTimeout(() => {
                // Draw the sprites (including the new player)
                this.map.drawSprites(this.sprites);
                Sprite.restoreNotifactionNumberForAllSprites();
                // Initialize the new player (taxi)
                this.player.initialize();
                // Reset other elements (e.g., people notifications)
                this.people.forEach(sprite => sprite.notify(sprite.original_notif_number));
                this.people.forEach(sprite => sprite.show());
            }, 800); //  delay
            setTimeout(() => {
                buttonResetElement.innerHTML = `<i class="fa-solid fa-rotate-right"></i> RESET`;
                buttonStepElement.innerHTML = `<i class="fa-solid fa-forward-step"></i> STEP`;
                buttonResetElement.disabled = false;
                buttonStepElement.disabled = false;
                buttonRunElement.disabled = false;
                buttonRunElement.style.display = "inline-block"; // Show RUN button
                buttonResetElement.style.display = "none"; // Hide RESET button
            }, 900); //  delay
        }
        getMapLayout() {
            return this.map.mapLayout;
        }

        async initializeBlocklyWorkspace() {
            if (!configData) {
                await fetchData();
            }
            this.blockManager = new BlockManager(blocklyDivElement, configData);
            this.blockManager.loadBlocks();
        }


        static giveHint(message, time) {
            const hint = buttonHintElement;
            $('#hint').addClass('hint-container');
            hint.textContent = message;
            setTimeout(() => {
                hint.textContent = "";
                $('#hint').removeClass('hint-container');
            }, time);

        }

        giveHint(message, time) {
            const hint = buttonHintElement;
            $('#hint').addClass('hint-container');
            hint.textContent = message;
            setTimeout(() => {
                hint.textContent = "";
                $('#hint').removeClass('hint-container');
            }, time);

        }


        addKeyInput(runCode, resetCode) {
            document.addEventListener("keydown", function (event) {
                const displayStyle = window.getComputedStyle(buttonRunElement).display; // Get computed display style
                const speedSlider = buttonSpeedElement; // Get the slider element

                if (event.code === "KeyR") {
                    if (displayStyle === "block") {
                        runCode();
                    } else if (displayStyle === "none") {
                        resetCode();
                    }
                } else if (event.code === "KeyS") {
                    alert("S key was pressed!");
                } else if (event.code === "KeyD") {
                    // Increase slider value
                    if (speedSlider) {
                        speedSlider.value = Math.min(parseInt(speedSlider.value) + 1, speedSlider.max);
                    }
                } else if (event.code === "KeyA") {
                    // Decrease slider value
                    if (speedSlider) {
                        speedSlider.value = Math.max(parseInt(speedSlider.value) - 1, speedSlider.min);
                    }
                }

            });
        }
        playSound(link) {
            const client_id = 'YOUR_CLIENT_ID';
            const trackUrl = 'https://soundcloud.com/yourusername/yourtrack'; // public track URL

            async function playBackgroundMusic() {
                const resolveResponse = await fetch(`https://api.soundcloud.com/resolve?url=${trackUrl}&client_id=${client_id}`);
                const trackData = await resolveResponse.json();

                const streamUrl = `${trackData.stream_url}?client_id=${client_id}`;
                const audio = new Audio(streamUrl);
                audio.loop = true;
                audio.play().catch(() => {
                    console.log("Autoplay blocked until user interacts.");
                });
            }
        }

    }


    class MapLayout {
        constructor(mapLayoutName, grid, app) {
            this.grid = grid;
            this.app = app;
            this.mapLayout = null;
            // this.mapRows = null;
            // this.mapCols = null;
            this.mapContainer = new PIXI.Container();
            this.app.stage.addChild(this.mapContainer);
        }

        async initialize(mapLayoutName) {
            this.mapLayout = await this.loadMapLayout(mapLayoutName); // Asynchronous operation
            this.mapRows = Object.keys(this.mapLayout).length;
            this.mapCols = Object.keys(this.mapLayout[Object.keys(this.mapLayout)[0]]).length;
        }


        async loadMapLayout(mapLayoutNameParam) {
            try {
                await fetchData();
                const layoutObj = configData.map_layouts.find(layout => layout.name === mapLayoutNameParam);
                return layoutObj ? layoutObj.layout : null;
            } catch (error) {
                console.error("Error fetching JSON:", error);
                return null;
            }
        }

        drawMap(gridSize) {
            this.reset();
            console.log('Drawing map with grid size:', gridSize);
            console.log('Map layout:', this.mapLayout);
            const parkColors = [0x00FF00, 0x228B22, 0x32CD32]; // Different shades of green
            let rowIndex = 0; // Track the numerical row index
            for (const rowKey in this.mapLayout) {
                let colIndex = 0; // Track the numerical column index
                for (const colKey in this.mapLayout[rowKey]) {
                    let tile = new PIXI.Graphics();
                    const tileValue = this.mapLayout[rowKey][colKey];
                    if (this.grid) tile.lineStyle(1, 0x9b9b9b, 1); // (width, color, alpha)
                    const parkColor = parkColors[Math.floor(Math.random() * parkColors.length)];
                    tile.beginFill(tileValue === 1 ? 0xCCCCCC : (tileValue === 2 ? parkColor : 0x555555));
                    tile.drawRect(colIndex * gridSize, rowIndex * gridSize, gridSize, gridSize);
                    tile.endFill();
                    this.mapContainer.addChild(tile);
                    colIndex++;
                }
                rowIndex++;
            }
        }

        drawSprites(listOfSprites) {
            if (listOfSprites) {
                listOfSprites.forEach((sprite) => {
                    if (sprite) this.app.stage.addChild(sprite.container);
                });
            }
        }

        reset() {
            if (this.mapContainer) {
                this.mapContainer.removeChildren();
            }
        }
    }

    class BlockManager {
        constructor(blocklyDiv, configData) {
            this.blocklyDiv = blocklyDiv;
            this.configData = configData;
            this.workspace = null;
            this.customTheme = null;
        }

        loadBlocks() {
            try {
                const data = this.configData;
                this.loadTheme(data.blocklyThemeSettings);
                this.defineBlocks(data.blocks);
                this.createToolbox(data.blocks);
                this.injectWorkspace();
                this.setupChangeListener();
                this.setupResizeObserver(); // Add resize listener

            } catch (error) {
                console.error('Error loading Blockly settings:', error);
            }
        }

        loadTheme(themeSettings) {
            if (themeSettings && themeSettings.length > 0) {
                const themeData = themeSettings[0];
                this.customTheme = Blockly.Theme.defineTheme(themeData.themeName, {
                    base: Blockly.Themes[themeData.base] || Blockly.Themes.Classic,
                    fontStyle: themeData.fontStyle,
                    componentStyles: themeData.componentStyles,
                    blockStyles: themeData.blockStyles
                });
            } else {
                console.error('No theme settings found in JSON.');
            }
        }

        defineBlocks(blocks) {
            if (!blocks || blocks.length === 0) {
                throw new Error('No blocks found in JSON.');
            }
            blocks.forEach(block => {
                Blockly.common.defineBlocksWithJsonArray([{...block}]);
                javascript.javascriptGenerator.forBlock[block.type] = () => block.javascript_function;
            });
            javascript.javascriptGenerator.forBlock['controls_repeat_ext'] = function (block) {
                let times = block.getFieldValue('TIMES') || 10; // Get number of repeats
                let innerCode = javascript.javascriptGenerator.statementToCode(block, 'DO'); // Get inner blocks
                let repeatCode = `
                for (let i = 0; i < ${times}; i++) {
                    ${innerCode}
                }
            `;
                return repeatCode; // âœ… Returns JavaScript code instead of calling repeat_10(block);
            };
        }

        createToolbox(blocks) {
            this.toolbox = {
                'kind': 'flyoutToolbox',
                'contents': blocks.map(block => ({'kind': 'block', 'type': block.type}))
            };
        }

        injectWorkspace() {
            this.workspace = Blockly.inject(this.blocklyDiv, {
                toolbox: this.toolbox,
                theme: this.customTheme,
                maxBlocks: 30,
                trashcan: true,
                move: {
                    scrollbars: {
                        horizontal: true,
                        vertical: true
                    },
                    drag: true,
                    wheel: true
                }
            });
        }

        setupChangeListener() {
            const updateCapacity = () => {
                buttonCapacityElement.textContent = this.workspace.remainingCapacity();
            };
            this.workspace.addChangeListener(updateCapacity);
            updateCapacity();
        }

        setupResizeObserver() {
            if (!buttonVisualisationElement) {
                console.error("ResizeObserver error: visualisation element not found.");
                return;
            }

            const resizeObserver = new ResizeObserver(() => {
                this.resizeBlocklyWorkspace();
            });

            resizeObserver.observe(buttonVisualisationElement);
        }

        // Resizes the Blockly workspace
        resizeBlocklyWorkspace() {
            if (this.workspace) {
                Blockly.svgResize(this.workspace);
            }
        }
    }


    class Sprite {
        static listOfSprites = [];
        static #numberOfEnvironmentSprites = 0;
        constructor(imageURL, row, col, showNotif = false, notif_number = 0, gridSize, app) {
            this.row = row;
            this.col = col;
            this._gridSize = gridSize;
            this.showNotif = showNotif;
            this.notif_number = notif_number;
            this.app = app;
            this.original_notif_number = notif_number;
            this.sprite = PIXI.Sprite.from(imageURL);
            this.sprite.anchor.set(0.5);
            this.updateSizeAndPosition();
            Object.defineProperty(this, "originalRow", {
                value: row,
                writable: false, // Prevent modification
                configurable: false, // Prevent redefinition
            });
            Object.defineProperty(this, "originalCol", {
                value: col,
                writable: false, // Prevent modification
                configurable: false, // Prevent redefinition
            });
            this.container = new PIXI.Container();
            this.container.addChild(this.sprite);

            if (this.showNotif) {
                this.notifText = new PIXI.Text(this.notif_number, {
                    fontFamily: 'Arial',
                    fontSize: 14,
                    fill: 'yellow',
                    fontWeight: 'bold',
                    stroke: 'black',
                    strokeThickness: 4
                });
                this.notifText.anchor.set(0.5);
                this.container.addChild(this.notifText);
                this.updateNotifPosition();
            }

            this.app.stage.addChild(this.container);
            Sprite.listOfSprites.push(this);
            Sprite.#numberOfEnvironmentSprites += notif_number;
        }

        static restoreNotifactionNumberForAllSprites(){
            Sprite.#numberOfEnvironmentSprites = 0;
            this.listOfSprites.forEach(sprite => Sprite.#numberOfEnvironmentSprites += sprite.original_notif_number);
        }

        notify(newNumber) {
            if (this.showNotif && this.notifText) {
                this.notif_number = newNumber;
                this.notifText.text = newNumber;
            }
        }
        static decreaseNumberOfEnvironmentSprites() {
            Sprite.#numberOfEnvironmentSprites--;
        }

        static hasEnvironmentSprites(){
            return Sprite.#numberOfEnvironmentSprites !== 0;
        }
        static getNumberOfEnvironmentSprites(){
            return Sprite.#numberOfEnvironmentSprites;
        }


        initialize() {
            this.row = this.originalRow;
            this.col = this.originalCol;
            this.updateSizeAndPosition();
            if (this.showNotif) {
                this.updateNotifPosition();
            }
        }


        resize(gridSize) {
            if (!this.sprite) {
                console.warn("Sprite is null or not yet loaded");
                return;
            }
            if (!this.sprite || !this.container) return;
            // Update sprite size
            this._gridSize = gridSize;
            this.sprite.width = this.sprite.height = gridSize;
            // Update position
            this.sprite.x = this.col * gridSize + gridSize / 2;
            this.sprite.y = this.row * gridSize + gridSize / 2;

            // Update notification position (if applicable)
            if (this.showNotif) {
                this.notifText.x = this.sprite.x + gridSize / 3;
                this.notifText.y = this.sprite.y - gridSize / 3;
            }
            // Ensure sprite remains on the stage
            if (!this.app.stage.children.includes(this.container)) {
                this.app.stage.addChild(this.container);
            }
        }

        updateSizeAndPosition() {
            this.sprite.width = this.sprite.height = this._gridSize;
            this.sprite.x = this.col * this._gridSize + this._gridSize / 2;
            this.sprite.y = this.row * this._gridSize + this._gridSize / 2;

        }

        updateNotifPosition() {
            this.notifText.x = this.sprite.x + this._gridSize / 3;
            this.notifText.y = this.sprite.y - this._gridSize / 3;
        }

        hide() {
            this.container.visible = false;
        }

        show() {
            this.container.visible = true;
        }

        isNextTo(otherSprite) {
            if (!otherSprite) return false; // Prevent errors if null

            const dRow = Math.abs(this.row - otherSprite.row);
            const dCol = Math.abs(this.col - otherSprite.col);

            return (dRow === 1 && dCol === 0) || (dRow === 0 && dCol === 1);
        }



    }

    class Player extends Sprite {
        static listOfPlayers = [];

        constructor(imageURL, row, col, showNotif = false, notifNumber = 0, gridSize, app) {
            super(imageURL, row, col, showNotif, notifNumber, gridSize, app);
            Player.listOfPlayers.push(this);
        }

        moveSmoothly(newRow, newCol, speed, isRunning, callback) {
            let targetX = newCol * this._gridSize + this._gridSize / 2;
            let targetY = newRow * this._gridSize + this._gridSize / 2;

            const animateMove = () => {
                if (!isRunning) {
                    this.sprite.x = targetX; // Snap to final position
                    this.sprite.y = targetY;
                    return;
                }
                let dx = targetX - this.sprite.x;
                let dy = targetY - this.sprite.y;

                if (Math.abs(dx) > 1 || Math.abs(dy) > 1) {
                    this.sprite.x += dx / speed;
                    this.sprite.y += dy / speed;
                    requestAnimationFrame(animateMove);
                } else {
                    this.sprite.x = targetX;
                    this.sprite.y = targetY;
                    this.row = newRow;
                    this.col = newCol;
                    if (typeof callback === "function") callback();
                }
            };

            requestAnimationFrame(animateMove);
        }

        moveBy(deltaCol, deltaRow, map_layout, speed, isRunning, callback) {
            let newRow = this.row + deltaRow;
            let newCol = this.col + deltaCol;
            let rowKey = Object.keys(map_layout)[newRow];
            let colKey = Object.keys(map_layout[rowKey])[newCol];
            if (map_layout[rowKey] && map_layout[rowKey][colKey] !== undefined &&
                (map_layout[rowKey][colKey] === 1 || map_layout[rowKey][colKey] === 2)) {
                this.moveSmoothly(newRow, newCol, speed, isRunning, callback);
            }

        }

        canMoveTo(row, col) {
            // Check if the player can move to the given position
            return !this.mapLayout.isObstacle(row, col);
        }


        async getPerson(activity, listOfSprites, speed, callback) {
            let person = listOfSprites.find(p => this.isNextTo(p));
            if (person) {
                console.log("person exists, notif: " + person.notif_number);
                if (person.notif_number > 1) {
                    console.log("Leftover sprites: " + Sprite.getNumberOfEnvironmentSprites());
                    Activity.giveHint("Removed 1 person", "3000");
                    await new Promise(resolve => setTimeout(resolve, speed * 100)); // 0.5 sec delay
                    Sprite.decreaseNumberOfEnvironmentSprites();
                    person.notify(person.notif_number - 1);
                } else if (person.notif_number === 1) {
                    console.log("Leftover sprites: " + Sprite.getNumberOfEnvironmentSprites());
                    Activity.giveHint("Everyone is inside", "3000");
                    person.notify(person.notif_number - 1);
                    Sprite.decreaseNumberOfEnvironmentSprites();
                    person.hide();
                }
                else if (person.notif_number <= 0) {
                    console.log("3 person exists, notif: " + person.notif_number);
                    Activity.giveHint("No person to be picked up", "3000");
                    activity.hasFailed();
                }
                if (typeof callback === "function") await callback(person);
                return person;
            } else {
                activity.hasFailed();
                Activity.giveHint("No person to be picked up", "150000");
            }
            if (!Sprite.hasEnvironmentSprites()){
                activity.levelCompleted();
            }
            if (typeof callback === "function") await callback(null);
            return null;
        }
    }

    $(document).ready(function () {
        $('#sidebarMenu .collapse').on('show.bs.collapse', function () {
            $('#sidebarMenu .collapse').not(this).collapse('hide');
        });

        // Change background of active dropdown
        $('#sidebarMenu .dropdown-toggle').on('click', function () {
            // Reset all dropdown backgrounds to default
            $('#sidebarMenu .nav-item').removeClass('active-bg-sidebar');
            $('#sidebarMenu .nav-item').addClass('bg-sidebar'); // Default background color

            // Apply bg-warning to the clicked (active) dropdown
            $(this).parent().removeClass('bg-sidebar').addClass('active-bg-sidebar');
        });
    });
    function toggleMenu() {
        let sidebar = document.getElementById("sidebar");
        let overlay = document.getElementById("overlay");
        sidebar.classList.toggle("show");
        overlay.classList.toggle("show");
    }
    new Activity({
        name: "Taxi Pickup",
        instructions: "Pick up all the passengers.",
        gridSize: 35,
        hints: "Use loops and conditionals!",
        mapLayout: "taxi_pickup_map_ten",
        sounds: "",
        blocks: "",
        goal: "",
        speedElement: buttonSpeedElement
    });
</script>
</body>
</html>