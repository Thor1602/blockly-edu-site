<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blockly by Mr. Thorben</title>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css"
          integrity="sha512-Evv84Mr4kqVGRNSgIGL/F/aIDqQb7xQ2vcrdIwxfjThSH8CSR7PBEakCr51Ck+w+/U6swU2Im1vVX0SVk9ABhg=="
          crossorigin="anonymous" referrerpolicy="no-referrer"/>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.5.1/gsap.min.js"></script>
    <script src="https://unpkg.com/blockly/blockly_compressed.js"></script>
    <script src="https://unpkg.com/blockly/blocks_compressed.js"></script>
    <script src="https://unpkg.com/blockly/javascript_compressed.js"></script>
    <script src="https://unpkg.com/blockly/msg/en.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.1.3/pixi.min.js"></script>
    <style>
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: none; /* Hidden initially */
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        body {
            overflow: hidden;
            padding: 0;
        }

        body, html {
            height: 100%;
            margin: 0;
        }

        .right-content {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .right-content .row {
            width: 100%;
        }

        /* ... (other styles) ... */
        .flex-container {
            display: flex;
            height: 100vh;
        }

        .flex-item-left { /* New class for the left item */
            flex: 0 0 33%; /* Takes 33% of the width */
        }

        .flex-item-right { /* New class for the right item */
            flex: 0 0 66%; /* Takes 66% of the width */
        }

        .btn-primary {
            background-color: #FF9800 !important;
            color: white !important;
            border-color: #FF9800 !important;
        }

        .btn-primary:hover,
        .btn-primary:visited,
        .btn-primary:active,
        .btn-primary:focus {
            background-color: #FF9800 !important;
            color: white !important;
            border-color: #FF9800 !important;
            box-shadow: none !important; /* Remove Bootstrap focus shadow */
        }

        .btn-primary:hover {
            box-shadow: 0 0 10px black !important; /* Adds black glow effect */
        }


        .btn-reset {
            background-color: #7200c3 !important;
            color: white !important;
            border-color: #7200c3 !important;
            display: none;
        }

        .btn-reset:hover,
        .btn-reset:visited,
        .btn-reset:active,
        .btn-reset:focus {
            background-color: #7200c3 !important;
            color: white !important;
            border-color: #7200c3 !important;
            box-shadow: none !important; /* Remove Bootstrap focus shadow */
        }

        .btn-reset:hover {
            box-shadow: 0 0 10px black !important; /* Adds black glow effect */
        }

        .pre-hint-container{
            height: 25px;
        }
        .hint-container{
            margin-left: 20px;
            height: 25px;
            background-color: white;
            color: black;
            padding-left: 20px;
            padding-right: 20px;
            border-radius: 20px;
        }
        /* styling for nav bar START */
        .offcanvas {
            position: fixed;
            top: 0;
            left: -250px; /* Initially hidden */
            width: 250px;
            height: 100%;
            background-color: #886500; /* yellow theme */
            color: white;
            overflow-y: auto;
            transition: 0.3s ease-in-out;
            padding-top: 60px;
            z-index: 1050; /* Above everything */
        }
        .offcanvas.show {
            left: 0; /* Slide in */
        }
        .offcanvas a {
            color: white;
            padding: 10px;
            display: block;
            text-decoration: none;
        }
        .offcanvas a:hover {
            background-color: #8c6c0d; /* yellow theme */
        }
        .close-btn {
            position: absolute;
            top: 10px;
            right: 20px;
            font-size: 24px;
            cursor: pointer;
        }

        /* Dark overlay when menu opens */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1045; /* Just below the sidebar */
            display: none; /* Hidden by default */
        }
        .overlay.show {
            display: block; /* Show when menu opens */
        }

        /* Navbar */
        .navbar {
            position: relative; /* No overlapping */
            z-index: 1030; /* Lower than sidebar */
        }

        /* Content */
        .content {
            padding: 20px;
        }
        .active-bg-sidebar {
            background-color: #8c6c0d; /* yellow theme */
        }
        .bg-sidebar {
            background-color: #886500; /* yellow theme */
        }
        /* styling for nav bar END */

    </style>
</head>
<body>

<nav class="navbar navbar-dark bg-warning">
    <div class="container-fluid">
        <!-- Hamburger Button -->
        <button class="navbar-toggler" type="button" onclick="toggleMenu()">
            <span class="navbar-toggler-icon"></span>
        </button>
        <img src="images/logo.png"  height="40px" width="40px" alt=""/> <a class="navbar-brand ml-3" href="#">Seoul Academy Apgujeong</a>
    </div>
</nav>

<!-- Dark Overlay (Shades Background) -->
<div id="overlay" class="overlay" onclick="toggleMenu()"></div>

<!-- Offcanvas Sidebar Menu -->
<div id="sidebar" class="offcanvas">
    <span class="close-btn" onclick="toggleMenu()">&times;</span>
    <ul class="nav flex-column" id="sidebarMenu">
        <!-- Grades with Submenus -->
        <li class="nav-item">
            <a href="#" class="nav-link dropdown-toggle" data-toggle="collapse" data-target="#kinderMenu" data-parent="#sidebarMenu">Kinder</a>
            <div id="kinderMenu" class="collapse">
                <a href="#" class="nav-link pl-4">Sequencing</a>
                <div class="pl-5">
                    <a href="#" class="nav-link" data-toggle="modal" data-target="#warningModal">Mr. Cab Driver 1</a>
                    <a href="#" class="nav-link">Mr. Cab Driver 2</a>
                    <a href="#" class="nav-link">Mr. Cab Driver 3</a>
                </div>
                <a href="#" class="nav-link pl-4">Loops</a>
                <a href="#" class="nav-link pl-4">Events</a>
            </div>
        </li>
        <li class="nav-item">
            <a href="#" class="nav-link dropdown-toggle" data-toggle="collapse" data-target="#grade1Menu" data-parent="#sidebarMenu">Grade 1</a>
            <div id="grade1Menu" class="collapse">
                <a href="#" class="nav-link pl-4">Sequencing</a>
                <div class="pl-5">
                    <a href="#" class="nav-link">Mr. Cab Driver 1</a>
                    <a href="#" class="nav-link">Mr. Cab Driver 2</a>
                    <a href="#" class="nav-link">Mr. Cab Driver 3</a>
                </div>
                <a href="#" class="nav-link pl-4">Loops</a>
                <a href="#" class="nav-link pl-4">Events</a>
            </div>
        </li>
        <li class="nav-item">
            <a href="#" class="nav-link dropdown-toggle" data-toggle="collapse" data-target="#grade2Menu" data-parent="#sidebarMenu">Grade 2</a>
            <div id="grade2Menu" class="collapse">
                <a href="#" class="nav-link pl-4">Sequencing</a>
                <div class="pl-5">
                    <a href="#" class="nav-link">Mr. Cab Driver 1</a>
                    <a href="#" class="nav-link">Mr. Cab Driver 2</a>
                    <a href="#" class="nav-link">Mr. Cab Driver 3</a>
                </div>
                <a href="#" class="nav-link pl-4">Loops</a>
                <a href="#" class="nav-link pl-4">Events</a>
            </div>
        </li>
        <li class="nav-item">
            <a href="#" class="nav-link dropdown-toggle" data-toggle="collapse" data-target="#grade3Menu" data-parent="#sidebarMenu">Grade 3</a>
            <div id="grade3Menu" class="collapse">
                <a href="#" class="nav-link pl-4">Sequencing</a>
                <div class="pl-5">
                    <a href="#" class="nav-link">Mr. Cab Driver 1</a>
                    <a href="#" class="nav-link">Mr. Cab Driver 2</a>
                    <a href="#" class="nav-link">Mr. Cab Driver 3</a>
                </div>
                <a href="#" class="nav-link pl-4">Loops</a>
                <a href="#" class="nav-link pl-4">Events</a>
            </div>
        </li>
        <li class="nav-item">
            <a href="#" class="nav-link dropdown-toggle" data-toggle="collapse" data-target="#grade4Menu" data-parent="#sidebarMenu">Grade 4</a>
            <div id="grade4Menu" class="collapse">
                <a href="#" class="nav-link pl-4">Sequencing</a>
                <div class="pl-5">
                    <a href="#" class="nav-link">Mr. Cab Driver 1</a>
                    <a href="#" class="nav-link">Mr. Cab Driver 2</a>
                    <a href="#" class="nav-link">Mr. Cab Driver 3</a>
                </div>
                <a href="#" class="nav-link pl-4">Loops</a>
                <a href="#" class="nav-link pl-4">Events</a>
            </div>
        </li>
        <li class="nav-item">
            <a href="#" class="nav-link dropdown-toggle" data-toggle="collapse" data-target="#grade5Menu" data-parent="#sidebarMenu">Grade 5</a>
            <div id="grade5Menu" class="collapse">
                <a href="#" class="nav-link pl-4">Sequencing</a>
                <div class="pl-5">
                    <a href="#" class="nav-link">Mr. Cab Driver 1</a>
                    <a href="#" class="nav-link">Mr. Cab Driver 2</a>
                    <a href="#" class="nav-link">Mr. Cab Driver 3</a>
                </div>
                <a href="#" class="nav-link pl-4">Loops</a>
                <div class="pl-5">
                    <a href="#" class="nav-link">Step 1</a>
                    <a href="#" class="nav-link">Step 2</a>
                    <a href="#" class="nav-link">Step 3</a>
                </div>
                <a href="#" class="nav-link pl-4">Events</a>
            </div>
        </li>
    </ul>
</div>
<div class="container-fluid vh-100 d-flex flex-row content">
    <!-- Left Side (Visualization) -->
    <div class="d-flex flex-column p-4">
        <h2>Mr. Cab Driver</h2>
        <div id="visualisation" class="border rounded bg-light p-3"></div>
        <div class="mt-3 d-flex justify-content-between">
            <button class="btn btn-lg btn-primary" id="btnRun">
                <i class="fa-solid fa-play"></i> RUN
            </button>
            <button class="btn btn-lg btn-reset" id="btnReset">
                <i class="fa-solid fa-rotate-right"></i> RESET
            </button>
            <button class="btn btn-lg btn-primary" id="btnStep">
                <i class="fa-solid fa-forward-step"></i> STEP
            </button>
        </div>
        <label for="speed" class="form-label"></label>
        <input type="range" class="form-range" min="0" max="10" step="1" id="speed" style="display: none">
    </div>

    <div class="d-flex flex-column flex-grow-1 p-4">
        <div class="bg-warning p-3 sticky-top">
            <h2>Instructions
                <span><button class="btn btn-primary">
                    <i class="fa-solid fa-question"></i> HINT
                </button></span>
            </h2>
            <p>Pick up everyone! Remaining blocks: <b>You have <span id="capacity"></span> block(s) left.</b></p>
            <div class="d-flex align-items-center">
                <div class="pre-hint-container" id="hint"></div> <!-- Custom margin in pixels -->
            </div>
        </div>
        <div class="border rounded bg-white p-4 flex-grow-1 mt-3">
            <div id="blocklyDiv" style="height: 100%; width: 100%;"></div>
        </div>
    </div>
</div>
<!-- Warning Modal -->
<div class="modal fade" id="warningModal" tabindex="-1" role="dialog" aria-labelledby="warningModalLabel" aria-hidden="true">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="warningModalLabel">Warning</h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body">
                This level is in development.
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-primary" data-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>
<script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.bundle.min.js"></script>

<script>
    // TODO solve the sizing issue where the taxi shows improper size and position behavior

    let configData = null; // Global variable to store JSON
    async function fetchData() {
        const response = await fetch('blocks.json'); // Adjust path as needed
        configData = await response.json();
    }

    buttonSpeedElement = document.getElementById('speed');
    buttonRunElement = document.getElementById("btnRun");
    buttonResetElement = document.getElementById("btnReset");
    buttonStepElement = document.getElementById("btnStep");
    buttonCapacityElement = document.getElementById("capacity");
    buttonVisualisationElement = document.getElementById("visualisation");
    buttonHintElement = document.getElementById("hint");
    blocklyDivElement = document.getElementById('blocklyDiv');


    class Activity {
        constructor(name, instructions, hints, mapLayout, sounds, blocks, goal, speedElement) {
            this.name = name;
            this.instructions = instructions;
            this.hints = hints;
            this.sprites = [];  // Initialize as empty arrays
            this.people = [];   // Initialize as empty arrays
            this.sounds = sounds;
            this.player = null;
            this.blocks = blocks;
            this.blockManager = null;
            this.goal = goal;
            this.map = null; // Initialize as null and set it later asynchronously
            this.app = null; // Initialize as null
            this.speed = 1;
            this.speedElement = speedElement;
            this.isRunning = false;
            buttonRunElement.addEventListener("click", () => {
                this.runCode();
            });
            buttonResetElement.addEventListener("click", () => {
                this.resetCode();
            });
            // Initialize the activity asynchronously
            this.initializeActivity(mapLayout);
            this.initializeBlocklyWorkspace();
            this.addKeyInput(this.runCode, this.resetCode);
            // window.addEventListener("resize", () => {
            //     this.map.setGridSize();
            //     this.app.renderer.resize(this.map.gridSize * this.map.mapCols, this.map.gridSize * this.map.mapRows);
            //     this.initializeEnvironment();
            //     this.map.drawSprites(this.sprites);  // Pass the correct 'sprites' array
            // });
        }


        // what my sprites will do according to the blocks
        pick_up() {
            return new Promise(resolve => this.player.getPerson(this.people, this.speed, resolve));
        }

        move_north() {
            return new Promise(resolve => this.player.moveBy(0, -1, this.getMapLayout(), this.speed, this.isRunning, resolve));
        }

        move_south() {
            return new Promise(resolve => this.player.moveBy(0, 1, this.getMapLayout(), this.speed, this.isRunning, resolve));
        }

        move_west() {
            return new Promise(resolve => this.player.moveBy(-1, 0, this.getMapLayout(), this.speed, this.isRunning, resolve));
        }

        move_east() {
            return new Promise(resolve =>
                this.player.moveBy(1, 0, this.getMapLayout(), this.speed, this.isRunning, this.isRunning, resolve));
        }

        runCodeBlock() {
            return new Promise(resolve => {
                this.giveHint("The code has started RUNNING", "3000");
                resolve(); // Resolve immediately after showing the hint
            });
        }


        // Running Blockly Code
        async runCode() {
            if (this.isRunning) return; // Prevent multiple executions
            this.isRunning = true;
            this.player.initialize();
            buttonRunElement.style.display = "none";
            buttonResetElement.style.display = "inline-block";
            let runEventBlock = this.blockManager.workspace.getAllBlocks().find(block => block.type === 'run_event');
            if (!runEventBlock) {
                this.giveHint("Error: Run block is missing. Please add the Run block.", "15000");
                this.isRunning = false; // Allow execution again
                return;
            }
            javascript.javascriptGenerator.init(this.blockManager.workspace);
            let code = javascript.javascriptGenerator.blockToCode(runEventBlock);
            try {
                await eval(`(async () => {
                    let checkRunning = () => this.isRunning; // Closure to check the flag
                    ${code.split("await").join("if (!checkRunning()) return; await")} // Insert check before each await
                })();`);
            } catch (error) {
                console.error("Error executing code:", error);
            } finally {
                this.isRunning = false;
            }
        }


        resetCode() {
            this.isRunning = false;
            // this.getMap().setGridSize();
            // this.initializeEnvironment();
            buttonResetElement.disabled = true;
            buttonStepElement.disabled = true;
            buttonRunElement.disabled = true;
            buttonResetElement.innerHTML = `
                    <span class="spinner-grow spinner-grow-sm" role="status" aria-hidden="true"></span>
                    LOAD
                `;
            buttonStepElement.innerHTML = `
                    <span class="spinner-grow spinner-grow-sm" role="status" aria-hidden="true"></span>
                    LOAD
                `;
            setTimeout(() => {
                // Draw the sprites (including the new player)
                this.map.drawSprites(this.sprites);
                // Initialize the new player (taxi)
                this.player.initialize();
                // Reset other elements (e.g., people notifications)
                this.people.forEach(sprite => sprite.updateNotif(sprite.original_notif_number));
            }, 800); //  delay
            setTimeout(() => {
                buttonResetElement.innerHTML = `<i class="fa-solid fa-rotate-right"></i> RESET`;
                buttonStepElement.innerHTML = `<i class="fa-solid fa-forward-step"></i> STEP`;
                buttonResetElement.disabled = false;
                buttonStepElement.disabled = false;
                buttonRunElement.disabled = false;
                buttonRunElement.style.display = "inline-block"; // Show RUN button
                buttonResetElement.style.display = "none"; // Hide RESET button
            }, 900); //  delay
        }

        async initializeActivity(mapLayout) {
            if (this.speed) {
                this.speedElement.style.display = "inline-block";
                this.speed = this.speedElement.value;
                this.speedElement.oninput = () => this.speed = this.speedElement.value;
            }
            // Initialize the PIXI application first with default values
            this.app = new PIXI.Application({
                width: 800, // Default placeholder values
                height: 600, // Default placeholder values
                backgroundColor: 0xAAAAAA
            });

            // Initialize the map first
            this.map = await new MapLayout(mapLayout, false, this.app);
            await this.map.initialize(mapLayout);
            this.map.setGridSize();


            // Now calculate the correct width and height based on map size
            this.app.renderer.resize(this.map.gridSize * this.map.mapCols, this.map.gridSize * this.map.mapRows);

            // Initialize player and people (sprites) after the app is ready

            this.player = new Player('https://i.postimg.cc/8C5cQSb0/taxi.png', 9, 11, false, 0, this.map.gridSize, this.app);
            let personOne = new Sprite('https://i.postimg.cc/wvRBMQZ5/person.png', 2, 4, true, 5, this.map.gridSize, this.app);
            let personTwo = new Sprite('https://i.postimg.cc/wvRBMQZ5/person.png', 7, 5, true, 2, this.map.gridSize, this.app);
            let personThree = new Sprite('https://i.postimg.cc/wvRBMQZ5/person.png', 8, 10, true, 3, this.map.gridSize, this.app);
            let personFour = new Sprite('https://i.postimg.cc/wvRBMQZ5/person.png', 6, 10, true, 1, this.map.gridSize, this.app);
            let personFive = new Sprite('https://i.postimg.cc/wvRBMQZ5/person.png', 5, 10, true, 1, this.map.gridSize, this.app);
            this.people = Sprite.listOfSprites.filter(item => !(item instanceof Player));
            this.sprites = Sprite.listOfSprites;
            // Append PIXI app view (canvas) to DOM
            buttonVisualisationElement.appendChild(this.app.view);

            this.initializeEnvironment();
            this.map.drawSprites(this.sprites);  // Pass the correct 'sprites' array

        }

        getMap() {
            return this.map;
        }

        getMapLayout() {
            return this.map.mapLayout;
        }

        initializeEnvironment() {
            if (!this.map) {
                console.error("Map is not initialized yet.");
                return;
            }

            if (this.sprites) {
                this.sprites.forEach((sprite) => {
                    if (sprite) sprite.resize(this.map.gridSize);
                });
            }
            this.map.drawMap();
        }

        checkGoal() {
            return this.goal.isMet(this);
        }


        resetActivity() {
            if (this.map && this.app) {
                this.map.reset();
                this.sprites.forEach(sprite => sprite.reset());
                this.player.reset();
            } else {
                console.error("Map or app is not initialized yet.");
            }
        }


        async initializeBlocklyWorkspace() {
            if (!configData) {
                await fetchData();
            }
            this.blockManager = new BlockManager(blocklyDivElement, configData);
            this.blockManager.loadBlocks();
        }


        static giveHint(message, time) {
            const hint = buttonHintElement;
            $('#hint').addClass('hint-container');
            hint.textContent = message;
            setTimeout(() => {
                hint.textContent = "";
                $('#hint').removeClass('hint-container');
            }, time);

        }

        giveHint(message, time) {
            const hint = buttonHintElement;
            $('#hint').addClass('hint-container');
            hint.textContent = message;
            setTimeout(() => {
                hint.textContent = "";
                $('#hint').removeClass('hint-container');
            }, time);

        }


        addKeyInput(runCode, resetCode) {
            document.addEventListener("keydown", function (event) {
                const displayStyle = window.getComputedStyle(buttonRunElement).display; // Get computed display style
                const speedSlider = buttonSpeedElement; // Get the slider element

                if (event.code === "KeyR") {
                    if (displayStyle === "block") {
                        runCode();
                    } else if (displayStyle === "none") {
                        resetCode();
                    }
                } else if (event.code === "KeyS") {
                    alert("S key was pressed!");
                } else if (event.code === "KeyD") {
                    // Increase slider value
                    if (speedSlider) {
                        speedSlider.value = Math.min(parseInt(speedSlider.value) + 1, speedSlider.max);
                    }
                } else if (event.code === "KeyA") {
                    // Decrease slider value
                    if (speedSlider) {
                        speedSlider.value = Math.max(parseInt(speedSlider.value) - 1, speedSlider.min);
                    }
                }

            });
        }
    }


    class MapLayout {
        constructor(mapLayoutName, grid, app) {
            this.gridSize = 40;
            this.grid = grid;
            this.app = app;
            this.mapLayout = null;
            this.mapRows = null;
            this.mapCols = null;

        }

        async initialize(mapLayoutName) {
            this.mapLayout = await this.loadMapLayout(mapLayoutName); // Asynchronous operation
            this.mapRows = Object.keys(this.mapLayout).length;
            this.mapCols = Object.keys(this.mapLayout[Object.keys(this.mapLayout)[0]]).length;
        }


        async loadMapLayout(mapLayoutNameParam) {
            try {
                await fetchData();
                const layoutObj = configData.map_layouts.find(layout => layout.name === mapLayoutNameParam);
                return layoutObj ? layoutObj.layout : null;
            } catch (error) {
                console.error("Error fetching JSON:", error);
                return null;
            }
        }


        setGridSize() {
            const breakpoints = [
                {width: 1300, size: 40},
                {width: 1000, size: 30},
                {width: 800, size: 20}
            ];
            this.gridSize = breakpoints.find(b => window.innerWidth > b.width)?.size || 10;
        }

        drawMap() {
            this.reset();
            const parkColors = [0x00FF00, 0x228B22, 0x32CD32]; // Different shades of green
            let rowIndex = 0; // Track the numerical row index
            for (const rowKey in this.mapLayout) {
                let colIndex = 0; // Track the numerical column index
                for (const colKey in this.mapLayout[rowKey]) {
                    let tile = new PIXI.Graphics();
                    const tileValue = this.mapLayout[rowKey][colKey];
                    if (this.grid) tile.lineStyle(1, 0x9b9b9b, 1); // (width, color, alpha)
                    const parkColor = parkColors[Math.floor(Math.random() * parkColors.length)];
                    tile.beginFill(tileValue === 1 ? 0xCCCCCC : (tileValue === 2 ? parkColor : 0x555555));
                    tile.drawRect(colIndex * this.gridSize, rowIndex * this.gridSize, this.gridSize, this.gridSize);
                    tile.endFill();
                    this.app.stage.addChild(tile);
                    colIndex++;
                }
                rowIndex++;
            }
        }

        drawSprites(listOfSprites) {
            if (listOfSprites) {
                listOfSprites.forEach((sprite) => {
                    if (sprite) this.app.stage.addChild(sprite.container);
                });
            }
        }

        reset() {
            if (this.app && this.app.stage) {
                this.app.stage.removeChildren();
            } else {
                console.error("PIXI app is not initialized yet.");
            }
        }
    }

    class BlockManager {
        constructor(blocklyDiv, configData) {
            this.blocklyDiv = blocklyDiv;
            this.configData = configData;
            this.workspace = null;
            this.customTheme = null;
        }

        loadBlocks() {
            try {
                const data = this.configData;
                this.loadTheme(data.blocklyThemeSettings);
                this.defineBlocks(data.blocks);
                this.createToolbox(data.blocks);
                this.injectWorkspace();
                this.setupChangeListener();
            } catch (error) {
                console.error('Error loading Blockly settings:', error);
            }
        }

        loadTheme(themeSettings) {
            if (themeSettings && themeSettings.length > 0) {
                const themeData = themeSettings[0];
                this.customTheme = Blockly.Theme.defineTheme(themeData.themeName, {
                    base: Blockly.Themes[themeData.base] || Blockly.Themes.Classic,
                    fontStyle: themeData.fontStyle,
                    componentStyles: themeData.componentStyles,
                    blockStyles: themeData.blockStyles
                });
            } else {
                console.error('No theme settings found in JSON.');
            }
        }

        defineBlocks(blocks) {
            if (!blocks || blocks.length === 0) {
                throw new Error('No blocks found in JSON.');
            }
            blocks.forEach(block => {
                Blockly.common.defineBlocksWithJsonArray([{...block}]);
                javascript.javascriptGenerator.forBlock[block.type] = () => block.javascript_function;
            });
            javascript.javascriptGenerator.forBlock['controls_repeat_ext'] = function (block) {
                let times = block.getFieldValue('TIMES') || 10; // Get number of repeats
                let innerCode = javascript.javascriptGenerator.statementToCode(block, 'DO'); // Get inner blocks
                let repeatCode = `
                for (let i = 0; i < ${times}; i++) {
                    ${innerCode}
                }
            `;
                return repeatCode; // ✅ Returns JavaScript code instead of calling repeat_10(block);
            };
        }

        createToolbox(blocks) {
            this.toolbox = {
                'kind': 'flyoutToolbox',
                'contents': blocks.map(block => ({'kind': 'block', 'type': block.type}))
            };
        }

        injectWorkspace() {
            this.workspace = Blockly.inject(this.blocklyDiv, {
                toolbox: this.toolbox,
                theme: this.customTheme,
                maxBlocks: 30,
                trashcan: true,
                move: {scrollbars: true}
            });
        }

        setupChangeListener() {
            const updateCapacity = () => {
                buttonCapacityElement.textContent = this.workspace.remainingCapacity();
            };
            this.workspace.addChangeListener(updateCapacity);
            updateCapacity();
        }
    }


    class Sprite {
        static listOfSprites = [];

        constructor(imageURL, row, col, showNotif = false, notif_number = 0, gridSize, app) {
            this.row = row;
            this.col = col;
            this.gridSize = gridSize;
            this.showNotif = showNotif;
            this.notif_number = notif_number;
            this.app = app;
            this.original_notif_number = notif_number;
            this.sprite = PIXI.Sprite.from(imageURL);
            this.sprite.anchor.set(0.5);
            this.updateSizeAndPosition();
            Object.defineProperty(this, "originalRow", {
                value: row,
                writable: false, // Prevent modification
                configurable: false, // Prevent redefinition
            });
            Object.defineProperty(this, "originalCol", {
                value: col,
                writable: false, // Prevent modification
                configurable: false, // Prevent redefinition
            });
            this.container = new PIXI.Container();
            this.container.addChild(this.sprite);

            if (this.showNotif) {
                this.notifText = new PIXI.Text(this.notif_number, {
                    fontFamily: 'Arial',
                    fontSize: 14,
                    fill: 'yellow',
                    fontWeight: 'bold',
                    stroke: 'black',
                    strokeThickness: 4
                });
                this.notifText.anchor.set(0.5);
                this.container.addChild(this.notifText);
                this.updateNotifPosition();
            }

            this.app.stage.addChild(this.container);
            Sprite.listOfSprites.push(this);
        }

        updateNotif(newNumber) {
            if (this.showNotif && this.notifText) {
                this.notif_number = newNumber;
                this.notifText.text = newNumber;
            }
        }

        initialize() {
            this.row = this.originalRow;
            this.col = this.originalCol;
            this.updateSizeAndPosition();
            if (this.showNotif) {
                this.updateNotifPosition();
            }
        }

        moveTo(newRow, newCol) {
            this.row = newRow;
            this.col = newCol;
            this.updateSizeAndPosition();
            if (this.showNotif) {
                this.updateNotifPosition();
            }
        }


        resize(gridSize) {
            // Update sprite size
            this.sprite.width = this.sprite.height = gridSize;

            // Update position
            this.sprite.x = this.col * gridSize + gridSize / 2;
            this.sprite.y = this.row * gridSize + gridSize / 2;

            // Update notification position (if applicable)
            if (this.showNotif) {
                this.notifText.x = this.sprite.x + gridSize / 3;
                this.notifText.y = this.sprite.y - gridSize / 3;
            }
            // Ensure sprite remains on the stage
            if (!this.app.stage.children.includes(this.container)) {
                this.app.stage.addChild(this.container);
            }
        }

        updateSizeAndPosition() {
            this.sprite.width = this.sprite.height = this.gridSize;
            this.sprite.x = this.col * this.gridSize + this.gridSize / 2;
            this.sprite.y = this.row * this.gridSize + this.gridSize / 2;

        }

        updateNotifPosition() {
            this.notifText.x = this.sprite.x + this.gridSize / 3;
            this.notifText.y = this.sprite.y - this.gridSize / 3;
        }

        remove() {
            this.app.stage.removeChild(this.container);
        }


        isNextTo(otherSprite) {
            if (!otherSprite) return false; // Prevent errors if null

            const dRow = Math.abs(this.row - otherSprite.row);
            const dCol = Math.abs(this.col - otherSprite.col);

            return (dRow === 1 && dCol === 0) || (dRow === 0 && dCol === 1);
        }


        playCrashSound() {
            let crashSound = new Audio('https://www.fesliyanstudios.com/play-mp3/4380'); // Replace with your sound URL
            crashSound.volume = 0.7; // Adjust volume
            crashSound.play();
        }
    }

    class Player extends Sprite {
        static listOfPlayers = [];

        constructor(imageURL, row, col, showNotif = false, notifNumber = 0, gridSize, app) {
            super(imageURL, row, col, showNotif, notifNumber, gridSize, app);
            Player.listOfPlayers.push(this);
        }

        moveSmoothly(newRow, newCol, speed, isRunning, callback) {
            let targetX = newCol * this.gridSize + this.gridSize / 2;
            let targetY = newRow * this.gridSize + this.gridSize / 2;

            const animateMove = () => {
                if (!isRunning) {
                    this.sprite.x = targetX; // Snap to final position
                    this.sprite.y = targetY;
                    return;
                }
                let dx = targetX - this.sprite.x;
                let dy = targetY - this.sprite.y;

                if (Math.abs(dx) > 1 || Math.abs(dy) > 1) {
                    this.sprite.x += dx / speed;
                    this.sprite.y += dy / speed;
                    requestAnimationFrame(animateMove);
                } else {
                    this.sprite.x = targetX;
                    this.sprite.y = targetY;
                    this.row = newRow;
                    this.col = newCol;
                    if (typeof callback === "function") callback();
                }
            };

            requestAnimationFrame(animateMove);
        }

        moveBy(deltaCol, deltaRow, map_layout, speed, isRunning, callback) {
            let newRow = this.row + deltaRow;
            let newCol = this.col + deltaCol;
            let rowKey = Object.keys(map_layout)[newRow];
            let colKey = Object.keys(map_layout[rowKey])[newCol];
            if (map_layout[rowKey] && map_layout[rowKey][colKey] !== undefined &&
                (map_layout[rowKey][colKey] === 1 || map_layout[rowKey][colKey] === 2)) {
                this.moveSmoothly(newRow, newCol, speed, isRunning, callback);
            }

        }

        canMoveTo(row, col) {
            // Check if the player can move to the given position
            return !this.mapLayout.isObstacle(row, col);
        }


        async getPerson(listOfSprites, speed, callback) {
            let person = listOfSprites.find(p => this.isNextTo(p));
            if (person) {
                if (person.notif_number > 1) {
                    Activity.giveHint("Removed 1 person", "3000");
                    await new Promise(resolve => setTimeout(resolve, speed * 100)); // 0.5 sec delay
                    person.updateNotif(person.notif_number - 1);
                } else if (person.notif_number === 1) {
                    Activity.giveHint("Everyone is inside", "3000");
                    person.remove();
                }
                if (typeof callback === "function") await callback(person);
                return person;
            } else {
                Activity.giveHint("No person", "3000");
            }
            if (typeof callback === "function") await callback(null);
            return null;
        }
    }
    $(document).ready(function () {
        $('#sidebarMenu .collapse').on('show.bs.collapse', function () {
            $('#sidebarMenu .collapse').not(this).collapse('hide');
        });

        // Change background of active dropdown
        $('#sidebarMenu .dropdown-toggle').on('click', function () {
            // Reset all dropdown backgrounds to default
            $('#sidebarMenu .nav-item').removeClass('active-bg-sidebar');
            $('#sidebarMenu .nav-item').addClass('bg-sidebar'); // Default background color

            // Apply bg-warning to the clicked (active) dropdown
            $(this).parent().removeClass('bg-sidebar').addClass('active-bg-sidebar');
        });
    });
    function toggleMenu() {
        let sidebar = document.getElementById("sidebar");
        let overlay = document.getElementById("overlay");

        sidebar.classList.toggle("show");
        overlay.classList.toggle("show");
    }
    //  constructor(name, instructions, hints, mapLayout, sounds, blocks, goal,speedElement) {
    activityOne = new Activity("", "", "", "taxi_pickup_map_twelve", "", "", "", buttonSpeedElement);


</script>
</body>
</html>